const std = @import("std");
const ascii = std.ascii;

const Tokenizer = @import("Tokenizer.zig");
const Diagnostic = parsing.Diagnostic;
const parsing = @import("parsing.zig");

const perf = @cImport(@cInclude("parse_mnemonic.c"));

pub const Instruction = struct {
    encoding: u32,
    extension: ?u32 = null,
    reloc: ?[]const u8 = null,
};

// ================================================================
//   ENCODINGS
// ================================================================

const DataTransfer = packed struct(u32) {
    offset: u10 = 0,
    n: u1 = 0,
    shift: u4 = 0,
    b: u1 = 0,
    h: u1 = 0,
    w: u1 = 0,
    m: u1 = 0,
    p: u1 = 0,
    rm: u4 = 0,
    rd: u4 = 0,
    i: u1 = 0,
    s: u1 = 0,
    _0: u2 = 0b00,
};

const MoveFromPsr = packed struct(u32) {
    _0: u24 = 0x01_8000,
    rd: u4 = 0,
    _1: u4 = 0,
};

const SetClearPsrBits = packed struct(u32) {
    operand: u10 = 0,
    _0: u7 = 0b110_0000,
    s: u1 = 0,
    _1: u10 = 0,
    i: u1 = 0,
    _2: u3 = 0b001,
};

const OP_ADD = 0b000;
const OP_ADC = 0b001;
const OP_SUB = 0b010;
const OP_SBC = 0b011;
const OP_AND = 0b100;
const OP_OR = 0b101;
const OP_XOR = 0b110;
const OP_BTC = 0b111;

const DataProcessing = packed struct(u32) {
    operand2: u10 = 0,
    shift: u5 = 0,
    d: u1 = 0,
    a: u1 = 0,
    op: u3 = 0,
    rm: u4 = 0,
    rd: u4 = 0,
    i: u1 = 0,
    h: u1 = 0,
    _0: u2 = 0b01,
};

const COND_EQ = 0b0000;
const COND_NE = 0b0001;
const COND_CS = 0b0010;
const COND_CC = 0b0011;
const COND_MI = 0b0100;
const COND_PL = 0b0101;
const COND_VS = 0b0110;
const COND_VC = 0b0111;
const COND_HI = 0b1000;
const COND_LS = 0b1001;
const COND_GE = 0b1010;
const COND_LT = 0b1011;
const COND_GT = 0b1100;
const COND_LE = 0b1101;
const COND_AL = 0b1110;

const Branch = packed struct(u32) {
    offset: u24 = 0,
    cond: u4 = 0,
    i: u1 = 0,
    l: u1 = 0,
    _0: u2 = 0b10,
};

const MoveImmediate = packed struct(u32) {
    immediate: u24 = 0,
    rd: u4 = 0,
    m: u1 = 0,
    _0: u3 = 0b110,
};

const SoftwareInterrupt = packed struct(u32) {
    comment: u28 = 0,
    _0: u4 = 0b1111,
};

// ================================================================
//   PARSING
// ================================================================

/// Parses an instruction, returning its machine code encoding.
pub fn toMachineCodeWord(line: *Tokenizer, diag: *Diagnostic) !?Instruction {
    const token = line.next().?;

    // Resolve mnemonic using perfect hash generated by gperf
    const mnem = perf.parseMnemonic(token.ptr, token.len);

    const inst = switch (mnem) {
        perf.LD => try encodeDataTransfer(line, diag, .{}),
        perf.LDB => try encodeDataTransfer(line, diag, .{ .b = 1 }),
        perf.LDSB => try encodeDataTransfer(line, diag, .{ .b = 1, .m = 1 }),
        perf.LDH => try encodeDataTransfer(line, diag, .{ .h = 1 }),
        perf.LDSH => try encodeDataTransfer(line, diag, .{ .h = 1, .m = 1 }),
        perf.ST => try encodeDataTransfer(line, diag, .{ .s = 1 }),
        perf.STB => try encodeDataTransfer(line, diag, .{ .s = 1, .b = 1 }),
        perf.STSB => try encodeDataTransfer(line, diag, .{ .s = 1, .b = 1, .m = 1 }),
        perf.STH => try encodeDataTransfer(line, diag, .{ .s = 1, .h = 1 }),
        perf.STSH => try encodeDataTransfer(line, diag, .{ .s = 1, .h = 1, .m = 1 }),
        perf.SMV => try encodeMoveFromPsr(line, diag),
        perf.SST => try encodeSetClearPsrBits(line, diag, .{ .s = 1 }),
        perf.SCL => try encodeSetClearPsrBits(line, diag, .{}),
        perf.NOT => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_XOR, .i = 1, .operand2 = 0x3FF }),
        perf.NOTX => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_XOR, .i = 1, .operand2 = 0x3FF, .a = 1 }),
        perf.LSL => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_OR }),
        perf.LSR => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_OR, .d = 1 }),
        perf.ASR => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_OR, .a = 1, .d = 1 }),
        perf.LSLX => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_OR, .a = 1 }),
        perf.TST => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_AND }),
        perf.TEQ => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_XOR }),
        perf.CMP => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_SUB }),
        perf.CPN => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_ADD }),
        perf.MOV => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_ADD, .a = 1 }),
        perf.NOP => try encodeDataProcessing(mnem, line, diag, .{ .op = OP_ADD, .a = 1 }),
        perf.MVI => try encodeMoveImmediate(line, diag),
        perf.SWI => try encodeSoftwareInterrupt(line, diag),
        perf.MOV32 => try encodeMove32(line, diag),
        else => blk: {
            if (mnem >= perf.ADD and mnem <= perf.BTC) {
                break :blk try encodeDataProcessing(mnem, line, diag, .{ .op = @intCast(mnem - perf.ADD) });
            } else if (mnem >= perf.ADDX and mnem <= perf.BTCX) {
                break :blk try encodeDataProcessing(mnem, line, diag, .{ .op = @intCast(mnem - perf.ADDX), .a = 1 });
            } else if (mnem >= perf.BEQ and mnem <= perf.B) {
                break :blk try encodeBranch(line, diag, .{ .cond = @intCast(mnem - perf.BEQ) });
            } else if (mnem >= perf.BLEQ and mnem <= perf.BL) {
                break :blk try encodeBranch(line, diag, .{ .cond = @intCast(mnem - perf.BLEQ), .l = 1 });
            }
            try diag.msg("invalid mnemonic\n", .{});
            return error.ParseError;
        },
    };

    // Catch extraneous tokens after otherwise correct instructions
    if (line.next()) |_| {
        try diag.msg("expected EOL\n", .{});
        return error.ParseError;
    }

    return inst;
}

fn encodeDataTransfer(line: *Tokenizer, diag: *Diagnostic, comptime flags: DataTransfer) !Instruction {
    var encoding = flags;

    encoding.rd = try parsing.expectRegister(line, diag);

    _ = try parsing.expectOperator(",", line, diag);
    _ = try parsing.expectOperator("[", line, diag);

    encoding.rm = try parsing.expectRegister(line, diag);

    switch (try parsing.expectOperator("]+-", line, diag)) {
        '+' => {},
        '-' => encoding.n = 1,
        ']' => {
            if (parsing.optionalOperator("+-", line)) |c| switch (c) {
                '+' => encoding.p = 1,
                '-' => {
                    encoding.n = 1;
                    encoding.p = 1;
                },
                '\n' => return .{ .encoding = @bitCast(encoding) },
                else => unreachable,
            } else {
                // Extraneous token
                try diag.msg("expected '+', '-', or 'EOL'\n", .{});
                return error.ParseError;
            }
        },
        else => unreachable,
    }

    if (parsing.expectRegisterOrValue(line, diag)) |op| switch (op) {
        .reg => |rn| encoding.offset = rn,
        .imm => |imm| {
            encoding.i = 1;

            // Must determine if the immediate value is representable as a
            // shifted 10-bit value
            if (imm <= 0x3FF) {
                // Immediate value fits as is
                encoding.offset = @intCast(imm);
            } else {
                // Find representation using shift, if possible
                const leadingZeros = @clz(imm);
                const trailingZeros = @ctz(imm);
                const windowSize = 32 - leadingZeros - trailingZeros;

                // All set bits must fit within in a 10-bit window
                if (windowSize > 10) {
                    try diag.msg("offset value not encodable\n", .{});
                    return error.ParseError;
                }

                // If the window is not left-aligned to 2-bits, then it may only be 9-bits wide
                if (leadingZeros % 2 == 1 and windowSize == 10) {
                    try diag.msg("offset value not encodable\n", .{});
                    return error.ParseError;
                }

                encoding.shift = @intCast(trailingZeros >> 1);
                encoding.offset = @intCast(imm >> @intCast(encoding.shift << 1));
            }

            // Early return if closing brace already seen
            if (encoding.p == 1) return .{ .encoding = @bitCast(encoding) };
        },
        else => unreachable,
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            try diag.msg("offset value not encodable\n", .{});
            return error.ParseError;
        },
        else => return err,
    }

    // ']' and '!' if no shift value
    if (encoding.p == 0) {
        if (parsing.optionalOperator("]", line) == ']') {
            if (parsing.optionalOperator("!", line) == '!') encoding.w = 1;
            return .{ .encoding = @bitCast(encoding) };
        }
    }

    // Parse shift for register offsets only
    if (encoding.i == 0) {
        // 'lsl'
        var token = line.next() orelse {
            // Early return if closing brace already seen
            if (encoding.p == 1) return .{ .encoding = @bitCast(encoding) };

            // Missing closing brace
            try diag.msg("expected ']' or 'lsl'\n", .{});
            return error.ParseError;
        };
        const mnem = perf.parseMnemonic(token.ptr, token.len);
        switch (mnem) {
            perf.LSL => {},
            else => {
                try diag.msg("expected ']', 'lsl', or 'EOL'\n", .{});
                return error.ParseError;
            },
        }

        // Shift value
        token = line.next() orelse {
            try diag.msg("expected register\n", .{});
            return error.ParseError;
        };
        if (parsing.parseInteger(token)) |shift| {
            // Must determine if shift value is multiple of two and less than 32
            if ((shift & ~@as(u32, 0x1E) != 0)) {
                try diag.msg("shift value not encodable\n", .{});
                return error.ParseError;
            }
            encoding.shift = @intCast(shift >> 1);
        } else |err| switch (err) {
            error.ValueNotEncodable => {
                try diag.msg("shift value not encodable\n", .{});
                return error.ParseError;
            },
            error.Unexpected => {
                try diag.msg("expected value\n", .{});
                return error.ParseError;
            },
            else => return err,
        }
    }

    // Early return if closing brace already seen
    if (encoding.p == 1) return .{ .encoding = @bitCast(encoding) };

    _ = try parsing.expectOperator("]", line, diag);
    if (parsing.optionalOperator("!", line) != '!') return .{ .encoding = @bitCast(encoding) };

    encoding.w = 1;
    return .{ .encoding = @bitCast(encoding) };
}

fn encodeMoveFromPsr(line: *Tokenizer, diag: *Diagnostic) !Instruction {
    return .{ .encoding = @bitCast(MoveFromPsr{ .rd = try parsing.expectRegister(line, diag) }) };
}

fn encodeSetClearPsrBits(line: *Tokenizer, diag: *Diagnostic, flags: SetClearPsrBits) !Instruction {
    var encoding = flags;

    // Rn or offset value
    if (parsing.expectRegisterOrValue(line, diag)) |op| switch (op) {
        .reg => |rn| encoding.operand = rn,
        .imm => |imm| {
            encoding.i = 1;

            // Must determine if the value is representable in 10-bits
            if (imm > 0x3FF) {
                try diag.msg("value is not encodable\n", .{});
                return error.ParseError;
            }

            encoding.operand = @intCast(imm);
        },
        else => unreachable,
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            try diag.msg("value is not encodable\n", .{});
            return error.ParseError;
        },
        else => return err,
    }

    return .{ .encoding = @bitCast(encoding) };
}

fn encodeDataProcessing(mnem: u32, line: *Tokenizer, diag: *Diagnostic, flags: DataProcessing) !Instruction {
    var encoding = flags;

    // NOP
    if (mnem == perf.NOP) return .{ .encoding = @bitCast(encoding) };

    // TST, TEQ, CMP, and CPN all hardcode Rd to R0 (default)
    if (!(mnem >= perf.TST and mnem <= perf.CPN)) {
        encoding.rd = try parsing.expectRegister(line, diag);
        _ = try parsing.expectOperator(",", line, diag);
    }

    if (mnem >= perf.LSL and mnem <= perf.LSLX) {
        // LSL, LSR, ASR, and LSLX do not take an Rm value, only Rn
        encoding.operand2 = try parsing.expectRegister(line, diag);
        _ = try parsing.expectOperator(",", line, diag);
    } else {
        encoding.rm = try parsing.expectRegister(line, diag);

        if (mnem == perf.MOV or mnem == perf.NOT or mnem == perf.NOTX) {
            return .{ .encoding = @bitCast(encoding) };
        }

        _ = try parsing.expectOperator(",", line, diag);

        const negated = if (parsing.optionalOperator("-", line) == '-') true else false;

        // Rn or immediate value
        if (parsing.expectRegisterOrValue(line, diag)) |op| switch (op) {
            .reg => |rn| {
                if (negated) {
                    try diag.msg("registers cannot be negated\n", .{});
                    return error.ParseError;
                }
                encoding.operand2 = rn;
            },
            .imm => |val| {
                encoding.i = 1;

                const imm = if (negated) ~val + 1 else val;

                // Must determine if the value is representable as a 10-bit signed value
                // The value may also be a positive 32-bit value where bits 9-31 are set
                if (imm > 0x1FF and imm & ~@as(u32, 0x1FF) != @as(u32, 0x1FF)) {
                    try diag.msg("value is not encodable\n", .{});
                    return error.ParseError;
                }

                encoding.operand2 = @intCast(imm & 0x3FF);
            },
            else => unreachable,
        } else |err| switch (err) {
            error.ValueNotEncodable => {
                try diag.msg("value is not encodable\n", .{});
                return error.ParseError;
            },
            else => return err,
        }

        // 'lsl', 'lsr', or 'asr'
        if (line.next()) |token| {
            const shiftMnem = perf.parseMnemonic(token.ptr, token.len);
            switch (shiftMnem) {
                perf.LSL => {},
                perf.LSR => {
                    if (flags.a == 1) {
                        try diag.msg("right shifts are not encodable for 'x' instruction variants\n", .{});
                        return error.ParseError;
                    }
                    encoding.d = 1;
                },
                perf.ASR => {
                    if (flags.a == 1) {
                        try diag.msg("right shifts are not encodable for 'x' instruction variants\n", .{});
                        return error.ParseError;
                    }
                    encoding.d = 1;
                    encoding.a = 1;
                },
                else => {
                    if (flags.a == 1) {
                        try diag.msg("expected 'lsl' or 'EOL'\n", .{});
                    } else {
                        try diag.msg("expected 'lsl', 'lsr', 'asr' or 'EOL'\n", .{});
                    }
                    return error.ParseError;
                },
            }
        } else {
            return .{ .encoding = @bitCast(encoding) };
        }
    }

    // Rs or immediate shift
    if (parsing.expectRegisterOrValue(line, diag)) |op| switch (op) {
        .reg => |rs| encoding.shift = rs,
        .imm => |shift| {
            encoding.h = 1;

            // Must determine if the shift is representable as a 5-bit value
            if (shift > 32 or (shift == 32 and encoding.d == 0)) {
                try diag.msg("shift value is not encodable\n", .{});
                return error.ParseError;
            }

            // 32-bit right shift is encoded as 0, so only update for < 32
            if (shift < 32) encoding.shift = @intCast(shift);
        },
        else => unreachable,
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            try diag.msg("shift value is not encodable\n", .{});
            return error.ParseError;
        },
        else => return err,
    }

    return .{ .encoding = @bitCast(encoding) };
}

fn encodeBranch(line: *Tokenizer, diag: *Diagnostic, flags: Branch) !Instruction {
    var encoding = flags;

    // Register or label
    const token = line.next() orelse {
        try diag.msg("expected register or label\n", .{});
        return error.ParseError;
    };
    if (parsing.parseOperand(token)) |op| switch (op) {
        .reg => |reg| {
            encoding.offset = reg;
            return .{ .encoding = @bitCast(encoding) };
        },
        .label => |label| return .{ .encoding = @bitCast(encoding), .reloc = label },
        else => {
            try diag.msg("expected register or label\n", .{});
            return error.ParseError;
        },
    } else |err| switch (err) {
        error.Unexpected => {
            try diag.msg("expected register or label\n", .{});
            return error.ParseError;
        },
        else => return err,
    }
}

fn encodeMoveImmediate(line: *Tokenizer, diag: *Diagnostic) !Instruction {
    var encoding = MoveImmediate{};

    encoding.rd = try parsing.expectRegister(line, diag);

    _ = try parsing.expectOperator(",", line, diag);

    // Test for optional '-'
    if (parsing.optionalOperator("-", line) == '-') encoding.m = 1;

    // Parse immediate value
    const token = line.next() orelse {
        try diag.msg("expected register\n", .{});
        return error.ParseError;
    };
    var imm = parsing.parseInteger(token) catch |err| {
        switch (err) {
            error.ValueNotEncodable => try diag.msg("value not encodable\n", .{}),
            error.Unexpected => try diag.msg("expected immediate value\n", .{}),
        }
        return error.ParseError;
    };

    if (encoding.m == 1) {
        //Take two's complement of parsed immediate value
        imm = ~imm + 1;

        // Ensure that value can be encoded by instruction
        if (imm < 0xFF00_0000) {
            try diag.msg("value not encodable\n", .{});
            return error.ParseError;
        }

        encoding.immediate = @truncate(imm);
        return .{ .encoding = @bitCast(encoding) };
    }

    // Ensure that value can be encoded by instruction
    if (imm & 0xFF00_0000 == 0xFF00_0000) {
        // Value is positive, but has 8 highest bits set
        encoding.m = 1;
    } else if (imm > 0x00FF_FFFF) {
        try diag.msg("value not encodable\n", .{});
        return error.ParseError;
    }

    encoding.immediate = @intCast(imm);
    return .{ .encoding = @bitCast(encoding) };
}

fn encodeSoftwareInterrupt(line: *Tokenizer, diag: *Diagnostic) !Instruction {
    var encoding = SoftwareInterrupt{};

    const token = line.next() orelse return .{ .encoding = @bitCast(encoding) };
    const comment = parsing.parseInteger(token) catch |err| switch (err) {
        error.Unexpected => {
            try diag.msg("expected value\n", .{});
            return error.ParseError;
        },
        error.ValueNotEncodable => {
            try diag.msg("comment value not encodable\n", .{});
            return error.ParseError;
        },
    };

    if ((comment & ~@as(u32, 0x0FFF_FFFF)) != 0) {
        try diag.msg("comment value not encodable\n", .{});
        return error.ParseError;
    }

    encoding.comment = @intCast(comment);
    return .{ .encoding = @bitCast(encoding) };
}

fn encodeMove32(line: *Tokenizer, diag: *Diagnostic) !Instruction {
    const rd = try parsing.expectRegister(line, diag);
    var mviInst = MoveImmediate{
        .rd = rd,
    };
    var addInst = DataProcessing{
        .h = 1,
        .i = 1,
        .rd = rd,
        .shift = 24,
        .a = 1,
    };

    _ = try parsing.expectOperator(",", line, diag);

    // Immediate or label
    const token = line.next() orelse {
        try diag.msg("label or value\n", .{});
        return error.ParseError;
    };
    if (parsing.parseOperand(token)) |op| switch (op) {
        .imm => |imm| {
            mviInst.immediate = @truncate(imm);
            addInst.operand2 = @intCast(imm >> 24);
            return .{
                .encoding = @bitCast(mviInst),
                .extension = @bitCast(addInst),
            };
        },
        .label => |label| return .{
            .encoding = @bitCast(mviInst),
            .extension = @bitCast(addInst),
            .reloc = label,
        },
        else => {
            try diag.msg("expected label or value\n", .{});
            return error.ParseError;
        },
    } else |err| switch (err) {
        error.Unexpected => {
            try diag.msg("expected label or value\n", .{});
            return error.ParseError;
        },
        else => return err,
    }
}

// ================================================================
//   Disassembly
// ================================================================

pub fn disassemble(allocator: std.mem.Allocator, machineCodeWord: u32) ![]u8 {
    var unknown: std.ArrayList(u8) = try std.ArrayList(u8).initCapacity(allocator, 8);
    try unknown.appendSlice("    ???");
    defer unknown.deinit();

    switch (machineCodeWord >> 30) {
        0b00 => {
            if (((machineCodeWord >> 15) & 0b11) == 0b11) {
                if (((machineCodeWord >> 29) & 1) == 1) {
                    return try disassembleSetClearPsrBits(allocator, machineCodeWord) orelse try unknown.toOwnedSlice();
                }
                return try disassembleMoveFromPsr(allocator, machineCodeWord) orelse try unknown.toOwnedSlice();
            }
            return try disassembleDataTransfer(allocator, machineCodeWord) orelse try unknown.toOwnedSlice();
        },
        0b01 => return try disassembleDataProcessing(allocator, machineCodeWord) orelse try unknown.toOwnedSlice(),
        0b10 => return try disassembleBranch(allocator, machineCodeWord) orelse try unknown.toOwnedSlice(),
        0b11 => {
            if (((machineCodeWord >> 29) & 1) == 1) {
                if (((machineCodeWord >> 28) & 1) == 1) {
                    return try disassembleSoftwareInterrupt(allocator, machineCodeWord) orelse try unknown.toOwnedSlice();
                }
                // Reserved
                return try disassembleSoftwareInterrupt(allocator, machineCodeWord) orelse try unknown.toOwnedSlice();
            }
            return try disassembleMoveImmediate(allocator, machineCodeWord) orelse try unknown.toOwnedSlice();
        },
        else => unreachable,
    }
    unreachable;
}

fn disassembleDataTransfer(allocator: std.mem.Allocator, machineCodeWord: u32) !?[]u8 {
    const encodedInst: DataTransfer = @bitCast(machineCodeWord);
    if (encodedInst._0 != 0b00) return null;
    var asmInst: std.ArrayList(u8) = try std.ArrayList(u8).initCapacity(allocator, 32);
    defer asmInst.deinit();
    try asmInst.appendSlice("    ");
    switch (encodedInst.s) {
        0 => try asmInst.appendSlice("ld"),
        1 => try asmInst.appendSlice("st"),
    }
    if (encodedInst.m == 1) try asmInst.append('s');
    if (encodedInst.h == 1) {
        try asmInst.append('h');
    } else if (encodedInst.b == 1) {
        try asmInst.append('b');
    }
    try asmInst.appendSlice(" r");
    try asmInst.writer().print("{}", .{encodedInst.rd});
    try asmInst.appendSlice(", [r");
    try asmInst.writer().print("{}", .{encodedInst.rm});
    if (encodedInst.p == 1) try asmInst.append(']');
    switch (encodedInst.n) {
        0 => try asmInst.appendSlice(" + "),
        1 => try asmInst.appendSlice(" - "),
    }
    if (encodedInst.i == 1) {
        const imm = encodedInst.offset << (encodedInst.shift * 2);
        try asmInst.writer().print("{}", .{imm});
    } else {
        try asmInst.writer().print("r{} lsl {}", .{ encodedInst.offset, encodedInst.shift * 2 });
    }
    if (encodedInst.p == 0) {
        try asmInst.append(']');
        if (encodedInst.w == 1) try asmInst.append('!');
    }
    return try asmInst.toOwnedSlice();
}

fn disassembleMoveFromPsr(allocator: std.mem.Allocator, machineCodeWord: u32) !?[]u8 {
    const encodedInst: MoveFromPsr = @bitCast(machineCodeWord);
    if (encodedInst._0 != 0x01_8000) return null;
    if (encodedInst._1 != 0) return null;
    var asmInst: std.ArrayList(u8) = try std.ArrayList(u8).initCapacity(allocator, 32);
    defer asmInst.deinit();
    try asmInst.appendSlice("    ");
    try asmInst.appendSlice("smv r");
    try asmInst.writer().print("{}", .{encodedInst.rd});
    return try asmInst.toOwnedSlice();
}

fn disassembleSetClearPsrBits(allocator: std.mem.Allocator, machineCodeWord: u32) !?[]u8 {
    const encodedInst: SetClearPsrBits = @bitCast(machineCodeWord);
    if (encodedInst._0 != 0b110_0000) return null;
    if (encodedInst._1 != 0) return null;
    if (encodedInst._2 != 0b001) return null;
    var asmInst: std.ArrayList(u8) = try std.ArrayList(u8).initCapacity(allocator, 32);
    defer asmInst.deinit();
    try asmInst.appendSlice("    ");
    switch (encodedInst.s) {
        0 => try asmInst.appendSlice("scl "),
        1 => try asmInst.appendSlice("sst "),
    }
    switch (encodedInst.i) {
        0 => try asmInst.writer().print("r{}", .{encodedInst.operand}),
        1 => try asmInst.writer().print("{}", .{encodedInst.operand}),
    }
    return try asmInst.toOwnedSlice();
}

fn disassembleDataProcessing(allocator: std.mem.Allocator, machineCodeWord: u32) !?[]u8 {
    const encodedInst: DataProcessing = @bitCast(machineCodeWord);
    if (encodedInst._0 != 0b01) return null;
    var asmInst: std.ArrayList(u8) = try std.ArrayList(u8).initCapacity(allocator, 32);
    defer asmInst.deinit();
    try asmInst.appendSlice("    ");
    switch (encodedInst.op) {
        0b000 => try asmInst.appendSlice("add"),
        0b001 => try asmInst.appendSlice("adc"),
        0b010 => try asmInst.appendSlice("sub"),
        0b011 => try asmInst.appendSlice("sbc"),
        0b100 => try asmInst.appendSlice("and"),
        0b101 => try asmInst.appendSlice("or"),
        0b110 => try asmInst.appendSlice("xor"),
        0b111 => try asmInst.appendSlice("btc"),
    }
    if (encodedInst.d == 0 and encodedInst.a == 1) {
        try asmInst.append('x');
    }
    try asmInst.writer().print(" r{}, r{}, ", .{ encodedInst.rd, encodedInst.rm });
    switch (encodedInst.i) {
        0 => try asmInst.writer().print("r{} ", .{encodedInst.operand2}),
        1 => try asmInst.writer().print("{} ", .{encodedInst.operand2}),
    }
    switch (encodedInst.a) {
        0 => try asmInst.append('l'),
        1 => try asmInst.append('a'),
    }
    switch (encodedInst.d) {
        0 => try asmInst.appendSlice("sl "),
        1 => try asmInst.appendSlice("sr "),
    }
    switch (encodedInst.h) {
        0 => try asmInst.writer().print("r{} ", .{encodedInst.shift}),
        1 => try asmInst.writer().print("{} ", .{encodedInst.shift}),
    }
    return try asmInst.toOwnedSlice();
}

fn disassembleBranch(allocator: std.mem.Allocator, machineCodeWord: u32) !?[]u8 {
    const encodedInst: Branch = @bitCast(machineCodeWord);
    if (encodedInst._0 != 0b10) return null;
    var asmInst: std.ArrayList(u8) = try std.ArrayList(u8).initCapacity(allocator, 32);
    defer asmInst.deinit();
    try asmInst.appendSlice("    ");
    try asmInst.append('b');
    if (encodedInst.l == 1) try asmInst.append('l');
    switch (encodedInst.cond) {
        0b0000 => try asmInst.appendSlice("eq "),
        0b0001 => try asmInst.appendSlice("ne "),
        0b0010 => try asmInst.appendSlice("cs "),
        0b0011 => try asmInst.appendSlice("cc "),
        0b0100 => try asmInst.appendSlice("mi "),
        0b0101 => try asmInst.appendSlice("pl "),
        0b0110 => try asmInst.appendSlice("vs "),
        0b0111 => try asmInst.appendSlice("hi "),
        0b1000 => try asmInst.appendSlice("ls "),
        0b1001 => try asmInst.appendSlice("ge "),
        0b1010 => try asmInst.appendSlice("lt "),
        0b1011 => try asmInst.appendSlice("gt "),
        0b1100 => try asmInst.appendSlice("le "),
        0b1101 => try asmInst.appendSlice("le "),
        0b1110 => try asmInst.appendSlice(" "),
        0b1111 => return null,
    }
    if (encodedInst.i == 1) {
        if (((encodedInst.offset >> 23) & 1) == 1) {
            try asmInst.append('-');
        }
        try asmInst.writer().print("{}", .{@as(u25, @truncate(@as(u26, encodedInst.offset) << 2))});
    } else {
        try asmInst.writer().print("r{}", .{encodedInst.offset});
    }
    return try asmInst.toOwnedSlice();
}

fn disassembleMoveImmediate(allocator: std.mem.Allocator, machineCodeWord: u32) !?[]u8 {
    const encodedInst: MoveImmediate = @bitCast(machineCodeWord);
    if (encodedInst._0 != 0b110) return null;
    var asmInst: std.ArrayList(u8) = try std.ArrayList(u8).initCapacity(allocator, 32);
    defer asmInst.deinit();
    try asmInst.appendSlice("    ");
    try asmInst.writer().print("mvi r{}, ", .{encodedInst.rd});
    const upperByte: u32 = if (encodedInst.m == 1) 0xFF00_0000 else 0;
    const imm = upperByte | @as(u32, @intCast(encodedInst.immediate));
    try asmInst.writer().print("{}", .{imm});
    return try asmInst.toOwnedSlice();
}

fn disassembleSoftwareInterrupt(allocator: std.mem.Allocator, machineCodeWord: u32) !?[]u8 {
    const encodedInst: SoftwareInterrupt = @bitCast(machineCodeWord);
    if (encodedInst._0 != 0b1111) return null;
    var asmInst: std.ArrayList(u8) = try std.ArrayList(u8).initCapacity(allocator, 32);
    defer asmInst.deinit();
    try asmInst.appendSlice("    ");
    try asmInst.writer().print("swi {}", .{encodedInst.comment});
    return try asmInst.toOwnedSlice();
}

// ================================================================
//   TESTS
// ================================================================

/// Unwraps Instruction returns from encode
fn INST(line: []const u8) !Instruction {
    var diag = try Diagnostic.init();
    var tokens = Tokenizer.init(line);
    if (toMachineCodeWord(&tokens, &diag)) |res| {
        return res orelse .{ .encoding = 0, .reloc = null };
    } else |err| switch (err) {
        error.ParseError => {
            // std.debug.print("ERROR: {s}", .{diag.text.slice()});
            return err;
        },
        else => return err,
    }
}

/// Unwraps Instruction returns from encode into raw u32 encodings
fn ENCODE(line: []const u8) !u32 {
    var diag = try Diagnostic.init();
    var tokens = Tokenizer.init(line);
    if (toMachineCodeWord(&tokens, &diag)) |res| {
        const inst = res orelse Instruction{ .encoding = 0, .extension = null, .reloc = null };
        return inst.encoding;
    } else |err| switch (err) {
        error.ParseError => {
            // std.debug.print("ERROR: {s}", .{diag.text.slice()});
            return err;
        },
        else => return err,
    }
}

test "Invalid mnemonic" {
    var diag = try Diagnostic.init();
    var line = Tokenizer.init("    bad");
    try std.testing.expectError(error.ParseError, toMachineCodeWord(&line, &diag));
}

// --- Data Transfer Instructions

// TODO I broke tests by swapping the m and n bits

test "DataTransfer -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("ld"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, ["));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 +"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 -"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 4"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl 4"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] +"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] -"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + r3 lsl"));
}

test "DataTransfer -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("ld!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 +!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 -!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 4!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 4 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl 4!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] +!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] -!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + r3 lsl!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + 4 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2]!"));
}

test "DataTransfer -- Unencodable offset value" {
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 0b1111_1111_111]"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + 0b1111_1111_111"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 0b1111_1111_110]"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + 0b1111_1111_110"));
}

test "DataTransfer -- Unencodable shift value" {
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl 1]"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl 32]"));
}

test "DataTransfer -- Mnemonic variants" {
    try std.testing.expectEqual(0x0120_0000, try ENCODE("ld    r1, [r2]"));
    try std.testing.expectEqual(0x0120_8000, try ENCODE("ldb   r1, [r2]"));
    try std.testing.expectEqual(0x0124_8000, try ENCODE("ldsb  r1, [r2]"));
    try std.testing.expectEqual(0x0121_0000, try ENCODE("ldh   r1, [r2]"));
    try std.testing.expectEqual(0x0125_0000, try ENCODE("ldsh  r1, [r2]"));
    try std.testing.expectEqual(0x2120_0000, try ENCODE("st    r1, [r2]"));
    try std.testing.expectEqual(0x2120_8000, try ENCODE("stb   r1, [r2]"));
    try std.testing.expectEqual(0x2124_8000, try ENCODE("stsb  r1, [r2]"));
    try std.testing.expectEqual(0x2121_0000, try ENCODE("sth   r1, [r2]"));
    try std.testing.expectEqual(0x2125_0000, try ENCODE("stsh  r1, [r2]"));
}

test "DataTransfer -- No writeback register offset" {
    try std.testing.expectEqual(0x0120_0003, try ENCODE("ld r1, [r2 + r3]"));
    try std.testing.expectEqual(0x0120_0403, try ENCODE("ld r1, [r2 - r3]"));
    try std.testing.expectEqual(0x0120_1003, try ENCODE("ld r1, [r2 + r3 lsl 4]"));
    try std.testing.expectEqual(0x0120_1403, try ENCODE("ld r1, [r2 - r3 lsl 4]"));
}

test "DataTransfer -- No writeback immediate" {
    try std.testing.expectEqual(0x1120_02AA, try ENCODE("ld r1, [r2 + 0x02AA]"));
    try std.testing.expectEqual(0x1120_06AA, try ENCODE("ld r1, [r2 - 0x02AA]"));
}

test "Datatransfer -- Pre-increment register offset" {
    try std.testing.expectEqual(0x0122_0003, try ENCODE("ld r1, [r2 + r3]!"));
    try std.testing.expectEqual(0x0122_0403, try ENCODE("ld r1, [r2 - r3]!"));
    try std.testing.expectEqual(0x0122_1003, try ENCODE("ld r1, [r2 + r3 lsl 4]!"));
    try std.testing.expectEqual(0x0122_1403, try ENCODE("ld r1, [r2 - r3 lsl 4]!"));
}

test "Datatransfer -- Pre-increment writeback immediate" {
    try std.testing.expectEqual(0x1122_02AA, try ENCODE("ld r1, [r2 + 0x02AA]!"));
    try std.testing.expectEqual(0x1122_06AA, try ENCODE("ld r1, [r2 - 0x02AA]!"));
}

test "Datatransfer -- Post-increment register offset" {
    try std.testing.expectEqual(0x0128_0003, try ENCODE("ld r1, [r2] + r3"));
    try std.testing.expectEqual(0x0128_0403, try ENCODE("ld r1, [r2] - r3"));
    try std.testing.expectEqual(0x0128_1003, try ENCODE("ld r1, [r2] + r3 lsl 4"));
    try std.testing.expectEqual(0x0128_1403, try ENCODE("ld r1, [r2] - r3 lsl 4"));
}

test "Datatransfer -- Post-increment writeback immediate" {
    try std.testing.expectEqual(0x1128_02AA, try ENCODE("ld r1, [r2] + 0x02AA"));
    try std.testing.expectEqual(0x1128_06AA, try ENCODE("ld r1, [r2] - 0x02AA"));
}

test "Datatransfer -- Implicitly shifted immediate" {
    try std.testing.expectEqual(0x1120_12AA, try ENCODE("ld r1, [r2 + 0x2AA0]"));
    try std.testing.expectEqual(0x1120_2851, try ENCODE("ld r1, [r2 + 0x14400]"));
    try std.testing.expectEqual(0x1120_1992, try ENCODE("ld r1, [r2 + 0x6480]"));
    try std.testing.expectEqual(0x1120_2341, try ENCODE("ld r1, [r2 + 0x34100]"));
}

// --- Move From PSR Instruction

test "MoveFromPsr -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("smv"));
}

test "MoveFromPsr -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("smv!"));
    try std.testing.expectError(error.ParseError, ENCODE("smv r1!"));
}

test "MoveFromPsr -- Encoding" {
    try std.testing.expectEqual(0x0101_8000, ENCODE("smv r1"));
}

// --- Set / Clear PSR Bits Instructions

test "SetClearPsrBits -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("sst"));
    try std.testing.expectError(error.ParseError, ENCODE("scl"));
}

test "SetClearPsrBits -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("sst!"));
    try std.testing.expectError(error.ParseError, ENCODE("sst r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("scl!"));
    try std.testing.expectError(error.ParseError, ENCODE("scl r1!"));
}

test "SetClearPsrBits -- Unencodable immediate value" {
    try std.testing.expectError(error.ParseError, ENCODE("sst 0xFFF"));
}

test "SetClearPsrBits -- Register value" {
    try std.testing.expectEqual(0x2003_8001, ENCODE("sst r1"));
    try std.testing.expectEqual(0x2001_8001, ENCODE("scl r1"));
}

// --- Data Processing Instructions

test "DataProcessing -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("add"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2,"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3 lsl"));
}

test "DataProcessing -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("add!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2,!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3 lsl!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3 lsl r4!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3 lsl 4!"));
}

test "DataProcessing -- Unencodable immediate value" {
    try std.testing.expectEqual(error.ParseError, ENCODE("add r1, r2, 0x200"));
}

test "DataProcessing -- Unencodable shift value" {
    try std.testing.expectEqual(error.ParseError, ENCODE("add r1, r2, r3 lsl 32"));
    try std.testing.expectEqual(error.ParseError, ENCODE("add r1, r2, r3 lsr 33"));
}

test "DataProcessing -- Opcode variants" {
    try std.testing.expectEqual(0x4120_0003, try ENCODE("add    r1, r2, r3"));
    try std.testing.expectEqual(0x4122_0003, try ENCODE("adc    r1, r2, r3"));
    try std.testing.expectEqual(0x4124_0003, try ENCODE("sub    r1, r2, r3"));
    try std.testing.expectEqual(0x4126_0003, try ENCODE("sbc    r1, r2, r3"));
    try std.testing.expectEqual(0x4128_0003, try ENCODE("and    r1, r2, r3"));
    try std.testing.expectEqual(0x412A_0003, try ENCODE("or     r1, r2, r3"));
    try std.testing.expectEqual(0x412C_0003, try ENCODE("xor    r1, r2, r3"));
    try std.testing.expectEqual(0x412E_0003, try ENCODE("btc    r1, r2, r3"));
    try std.testing.expectEqual(0x4121_0003, try ENCODE("addx   r1, r2, r3"));
    try std.testing.expectEqual(0x4123_0003, try ENCODE("adcx   r1, r2, r3"));
    try std.testing.expectEqual(0x4125_0003, try ENCODE("subx   r1, r2, r3"));
    try std.testing.expectEqual(0x4127_0003, try ENCODE("sbcx   r1, r2, r3"));
    try std.testing.expectEqual(0x4129_0003, try ENCODE("andx   r1, r2, r3"));
    try std.testing.expectEqual(0x412B_0003, try ENCODE("orx    r1, r2, r3"));
    try std.testing.expectEqual(0x412D_0003, try ENCODE("xorx   r1, r2, r3"));
    try std.testing.expectEqual(0x412F_0003, try ENCODE("btcx   r1, r2, r3"));
}

test "DataProcessing -- Immediate value" {
    try std.testing.expectEqual(0x5120_00AA, try ENCODE("add r1, r2, 0xAA"));
}

test "DataProcessing -- Register value, register shift" {
    try std.testing.expectEqual(0x4120_1003, try ENCODE("add r1, r2, r3 lsl r4"));
    try std.testing.expectEqual(0x4120_9003, try ENCODE("add r1, r2, r3 lsr r4"));
    try std.testing.expectEqual(0x4121_9003, try ENCODE("add r1, r2, r3 asr r4"));
}

test "DataProcessing -- Immediate value, register shift" {
    try std.testing.expectEqual(0x5120_10AA, try ENCODE("add r1, r2, 0xAA lsl r4"));
    try std.testing.expectEqual(0x5120_90AA, try ENCODE("add r1, r2, 0xAA lsr r4"));
    try std.testing.expectEqual(0x5121_90AA, try ENCODE("add r1, r2, 0xAA asr r4"));
}

test "DataProcessing -- Register value, immediate shift" {
    try std.testing.expectEqual(0x6120_1003, try ENCODE("add r1, r2, r3 lsl 4"));
    try std.testing.expectEqual(0x6120_9003, try ENCODE("add r1, r2, r3 lsr 4"));
    try std.testing.expectEqual(0x6121_9003, try ENCODE("add r1, r2, r3 asr 4"));
    try std.testing.expectEqual(0x6120_8003, try ENCODE("add r1, r2, r3 lsr 32"));
}

test "DataProcessing -- Immediate value, immediate shift" {
    try std.testing.expectEqual(0x7120_10AA, try ENCODE("add r1, r2, 0xAA lsl 4"));
    try std.testing.expectEqual(0x7120_90AA, try ENCODE("add r1, r2, 0xAA lsr 4"));
    try std.testing.expectEqual(0x7121_90AA, try ENCODE("add r1, r2, 0xAA asr 4"));
    try std.testing.expectEqual(0x7120_80AA, try ENCODE("add r1, r2, 0xAA lsr 32"));
}

// --- Data Processing Pseudo-Instructions

test "DataProcessing Pseudo -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("tst"));
    try std.testing.expectError(error.ParseError, ENCODE("tst r1"));
    try std.testing.expectError(error.ParseError, ENCODE("tst r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("not"));
    try std.testing.expectError(error.ParseError, ENCODE("not r1"));
    try std.testing.expectError(error.ParseError, ENCODE("not r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1, r2,"));
    try std.testing.expectError(error.ParseError, ENCODE("mov"));
    try std.testing.expectError(error.ParseError, ENCODE("mov,"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1,"));
}

test "DataProcessing Pseudo -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("nop!"));
    try std.testing.expectError(error.ParseError, ENCODE("tst!"));
    try std.testing.expectError(error.ParseError, ENCODE("tst r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("tst r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("not!"));
    try std.testing.expectError(error.ParseError, ENCODE("not r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("not r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1, r2,!"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1, r2, r3!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov,!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1, r2!"));
}

test "DataProcessing Pseudo -- Instruction variants" {
    try std.testing.expectEqual(0x4001_0000, try ENCODE("nop"));
    try std.testing.expectEqual(0x4018_0002, try ENCODE("tst    r1, r2"));
    try std.testing.expectEqual(0x401C_0002, try ENCODE("teq    r1, r2"));
    try std.testing.expectEqual(0x4014_0002, try ENCODE("cmp    r1, r2"));
    try std.testing.expectEqual(0x4010_0002, try ENCODE("cpn    r1, r2"));
    try std.testing.expectEqual(0x512C_03FF, try ENCODE("not    r1, r2"));
    try std.testing.expectEqual(0x512D_03FF, try ENCODE("notx   r1, r2"));
    try std.testing.expectEqual(0x410A_0C02, try ENCODE("lsl    r1, r2, r3"));
    try std.testing.expectEqual(0x410A_8C02, try ENCODE("lsr    r1, r2, r3"));
    try std.testing.expectEqual(0x410B_8C02, try ENCODE("asr    r1, r2, r3"));
    try std.testing.expectEqual(0x410B_0C02, try ENCODE("lslx   r1, r2, r3"));
    try std.testing.expectEqual(0x4121_0000, try ENCODE("mov    r1, r2"));
}

// --- Branch Instructions

test "Branch -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, INST("b"));
}

test "Branch -- Unexpected token" {
    try std.testing.expectError(error.ParseError, INST("b!"));
    try std.testing.expectError(error.ParseError, INST("b r1!"));
    try std.testing.expectError(error.ParseError, INST("b label!"));
}

test "Branch -- Instruction variants, register" {
    try std.testing.expectEqual(Instruction{ .encoding = 0x8000_0001 }, try INST("beq     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8100_0001 }, try INST("bne     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8200_0001 }, try INST("bcs     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8300_0001 }, try INST("bcc     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8400_0001 }, try INST("bmi     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8500_0001 }, try INST("bpl     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8600_0001 }, try INST("bvs     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8700_0001 }, try INST("bvc     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8800_0001 }, try INST("bhi     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8900_0001 }, try INST("bls     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8A00_0001 }, try INST("bge     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8B00_0001 }, try INST("blt     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8C00_0001 }, try INST("bgt     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8D00_0001 }, try INST("ble     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8E00_0001 }, try INST("b       r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA000_0001 }, try INST("bleq    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA100_0001 }, try INST("blne    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA200_0001 }, try INST("blcs    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA300_0001 }, try INST("blcc    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA400_0001 }, try INST("blmi    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA500_0001 }, try INST("blpl    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA600_0001 }, try INST("blvs    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA700_0001 }, try INST("blvc    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA800_0001 }, try INST("blhi    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA900_0001 }, try INST("blls    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAA00_0001 }, try INST("blge    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAB00_0001 }, try INST("bllt    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAC00_0001 }, try INST("blgt    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAD00_0001 }, try INST("blle    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAE00_0001 }, try INST("bl      r1"));
}

test "Branch -- Instruction variants, label" {
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8000_0000, .reloc = "label" }, try INST("beq     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8100_0000, .reloc = "label" }, try INST("bne     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8200_0000, .reloc = "label" }, try INST("bcs     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8300_0000, .reloc = "label" }, try INST("bcc     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8400_0000, .reloc = "label" }, try INST("bmi     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8500_0000, .reloc = "label" }, try INST("bpl     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8600_0000, .reloc = "label" }, try INST("bvs     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8700_0000, .reloc = "label" }, try INST("bvc     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8800_0000, .reloc = "label" }, try INST("bhi     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8900_0000, .reloc = "label" }, try INST("bls     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8A00_0000, .reloc = "label" }, try INST("bge     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8B00_0000, .reloc = "label" }, try INST("blt     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8C00_0000, .reloc = "label" }, try INST("bgt     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8D00_0000, .reloc = "label" }, try INST("ble     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8E00_0000, .reloc = "label" }, try INST("b       label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA000_0000, .reloc = "label" }, try INST("bleq    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA100_0000, .reloc = "label" }, try INST("blne    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA200_0000, .reloc = "label" }, try INST("blcs    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA300_0000, .reloc = "label" }, try INST("blcc    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA400_0000, .reloc = "label" }, try INST("blmi    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA500_0000, .reloc = "label" }, try INST("blpl    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA600_0000, .reloc = "label" }, try INST("blvs    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA700_0000, .reloc = "label" }, try INST("blvc    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA800_0000, .reloc = "label" }, try INST("blhi    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA900_0000, .reloc = "label" }, try INST("blls    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAA00_0000, .reloc = "label" }, try INST("blge    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAB00_0000, .reloc = "label" }, try INST("bllt    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAC00_0000, .reloc = "label" }, try INST("blgt    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAD00_0000, .reloc = "label" }, try INST("blle    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAE00_0000, .reloc = "label" }, try INST("bl      label"));
}

// --- Move Immediate Instruction

test "MoveImmediate -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("mvi"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1,"));
}

test "MoveImmediate -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("mvi!"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1,!"));
}

test "MoveImmediate -- Unencodable value" {
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1, 0x01FF_FFFF"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1, -0x01FF_FFFF"));
}

test "MoveImmediate -- Encoding" {
    try std.testing.expectEqual(0xC100_00AA, ENCODE("mvi r1, 0xAA"));
    try std.testing.expectEqual(0xD1FF_FF56, ENCODE("mvi r1, -0xAA"));
}

// --- Software Interrupt Instruction

test "SoftwareInterrupt -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("swi!"));
    try std.testing.expectError(error.ParseError, ENCODE("swi 0xAA!"));
}

test "SoftwareInterrupt -- Unencodable value" {
    try std.testing.expectError(error.ParseError, ENCODE("swi 0xDEAD_BEEF"));
}

test "SoftwareInterrupt -- Encoding" {
    try std.testing.expectEqual(0xFEAD_BEEF, ENCODE("swi 0x0EAD_BEEF"));
}

// --- Move32 Instruction

test "Move32 -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("mov32"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1,"));
}

test "Move32 -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("mov32!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1, label!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1, 0xDEAD_BEEF!"));
}

test "Move32 -- Unencodable value" {
    try std.testing.expectError(error.ParseError, ENCODE("mov32, r1, 0xFFFF_FFFF_FFFF"));
}

test "Move32 -- Encoding, label" {
    try std.testing.expectEqualDeep(
        Instruction{ .encoding = 0xC100_0000, .extension = 0x7101_6000, .reloc = "label" },
        try INST("mov32 r1, label"),
    );
}

test "Move32 -- Encoding, immediate" {
    try std.testing.expectEqual(
        Instruction{ .encoding = 0xC1AD_BEEF, .extension = 0x7101_60DE },
        try INST("mov32 r1, 0xdeadbeef"),
    );
}

fn chewUpAndSpitOut(allocator: std.mem.Allocator, str: []const u8) !void {
    var line = Tokenizer.init(str);
    var diag = try Diagnostic.init();
    const inst: Instruction = try toMachineCodeWord(&line, &diag) orelse return error.ParseError;
    const encoding = try disassemble(allocator, inst.encoding);
    std.debug.print("{x:0>8}: {s}\n", .{ inst.encoding, encoding });
    allocator.free(encoding);
    if (inst.extension) |ext| {
        const extension = try disassemble(allocator, ext);
        std.debug.print("{x:0>8}: {s}\n", .{ ext, extension });
        allocator.free(extension);
    }
}

test "disassemble" {
    const ta = std.testing.allocator;
    try chewUpAndSpitOut(ta, "ldb r4, [r5 + 7]");
    try chewUpAndSpitOut(ta, "nop");
    try chewUpAndSpitOut(ta, "not r3, r3");
    try chewUpAndSpitOut(ta, "mov r3, r6");
    try chewUpAndSpitOut(ta, "swi 2048");
    try chewUpAndSpitOut(ta, "mov32 r8, 0xdeadbeef");
    try chewUpAndSpitOut(ta, "teq r8, 24");
    try chewUpAndSpitOut(ta, "btc r8, r8, 0b1001");
    const encoding = try disassemble(ta, 0x0001_8001);
    std.debug.print("{x:0>8}: {s}\n", .{ 0x0001_8001, encoding });
    ta.free(encoding);
}

const std = @import("std");
const ascii = std.ascii;

const Tokenizer = @import("tokenizer.zig").Tokenizer;

const errMsg = @import("error_message.zig");

const perf = @cImport(@cInclude("parse_mnemonic.c"));

const Instruction = struct {
    encoded: u32,
    relocationSymbol: ?[]u8,
};

// ================================================================
//   INSTRUCTION ENCODINGS AND FLAGS
// ================================================================

const INSTR_DATA_TRANSFER: u32 = 0x0000_0000;
const FLAGS_DT_S: u32 = 1 << 29;
const FLAGS_DT_I: u32 = 1 << 28;
const FLAGS_DT_P: u32 = 1 << 19;
const FLAGS_DT_N: u32 = 1 << 18;
const FLAGS_DT_W: u32 = 1 << 17;
const FLAGS_DT_H: u32 = 1 << 16;
const FLAGS_DT_B: u32 = 1 << 15;
const FLAGS_DT_M: u32 = 1 << 10;

const INSTR_MOVE_FROM_PSR: u32 = 0x0001_8000;

const INSTR_SET_CLEAR_PSR_BITS: u32 = 0x2001_8000;
const FLAGS_PSR_I: u32 = 1 << 28;
const FLAGS_PSR_S: u32 = 1 << 17;

const INSTR_DATA_PROCESSING: u32 = 0x4000_0000;

const INSTR_BRANCH: u32 = 0x8000_0000;
const FLAGS_B_L: u32 = 1 << 29;
const COND_EQ: u32 = 0b0000 << 17;
const COND_NE: u32 = 0b0001 << 17;
const COND_CS: u32 = 0b0010 << 17;
const COND_CC: u32 = 0b0011 << 17;
const COND_MI: u32 = 0b0100 << 17;
const COND_PL: u32 = 0b0101 << 17;
const COND_VS: u32 = 0b0110 << 17;
const COND_VC: u32 = 0b0111 << 17;
const COND_HI: u32 = 0b1000 << 17;
const COND_LS: u32 = 0b1001 << 17;
const COND_GE: u32 = 0b1010 << 17;
const COND_LT: u32 = 0b1011 << 17;
const COND_GT: u32 = 0b1100 << 17;
const COND_LE: u32 = 0b1101 << 17;
const COND_AL: u32 = 0b1110 << 17;

const INSTR_MOVE_IMMEDIATE: u32 = 0xC000_0000;
const FLAGS_MI_M: u32 = 1 << 28;

const INSTR_SOFTWARE_INTERRUPT: u32 = 0xF000_0000;

// ================================================================
//   INSTRUCTION PARSING
// ================================================================

pub fn encodeInstruction(line: [:0]const u8) !?Instruction {
    var tokenizer = Tokenizer.init(line);
    const token = tokenizer.next() orelse return null;

    // Line is only a comment
    if (token[0] == ';') return null;

    // Resolve mnemonic using perfect hash generated by gperf
    const mnem = perf.parseMnemonic(token.ptr, token.len);
    const encoding = switch (mnem) {
        perf.LD => try encodeDataTransfer(&tokenizer, 0),
        perf.LDB => try encodeDataTransfer(&tokenizer, FLAGS_DT_B),
        perf.LDSB => try encodeDataTransfer(&tokenizer, FLAGS_DT_B | FLAGS_DT_M),
        perf.LDH => try encodeDataTransfer(&tokenizer, FLAGS_DT_H),
        perf.LDSH => try encodeDataTransfer(&tokenizer, FLAGS_DT_H | FLAGS_DT_M),
        perf.ST => try encodeDataTransfer(&tokenizer, FLAGS_DT_S),
        perf.STB => try encodeDataTransfer(&tokenizer, FLAGS_DT_S | FLAGS_DT_B),
        perf.STSB => try encodeDataTransfer(&tokenizer, FLAGS_DT_S | FLAGS_DT_B | FLAGS_DT_M),
        perf.STH => try encodeDataTransfer(&tokenizer, FLAGS_DT_S | FLAGS_DT_H),
        perf.STSH => try encodeDataTransfer(&tokenizer, FLAGS_DT_S | FLAGS_DT_H | FLAGS_DT_M),
        perf.SMV => try encodeMoveFromPsr(&tokenizer),
        perf.SST => encodeSetClearPsrBits(&tokenizer, FLAGS_PSR_S),
        perf.SCL => encodeSetClearPsrBits(&tokenizer, 0),
        // perf.ADD => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.ADC => encodeDataProcessing(mnem, tokenizer, OPCODE_ADC),
        // perf.SUB => encodeDataProcessing(mnem, tokenizer, OPCODE_SUB),
        // perf.SBC => encodeDataProcessing(mnem, tokenizer, OPCODE_SBC),
        // perf.AND => encodeDataProcessing(mnem, tokenizer, OPCODE_AND),
        // perf.OR => encodeDataProcessing(mnem, tokenizer, OPCODE_OR),
        // perf.XOR => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.BTC => encodeDataProcessing(mnem, tokenizer, OPCODE_BTC),
        // perf.NOT => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.ADDX => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.ADCX => encodeDataProcessing(mnem, tokenizer, OPCODE_ADC),
        // perf.SUBX => encodeDataProcessing(mnem, tokenizer, OPCODE_SUB),
        // perf.SBCX => encodeDataProcessing(mnem, tokenizer, OPCODE_SBC),
        // perf.ANDX => encodeDataProcessing(mnem, tokenizer, OPCODE_AND),
        // perf.ORX => encodeDataProcessing(mnem, tokenizer, OPCODE_OR),
        // perf.XORX => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.BTCX => encodeDataProcessing(mnem, tokenizer, OPCODE_BTC),
        // perf.NOTX => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.LSL => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.LSR => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.ASR => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.LSLX => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.TST => encodeDataProcessing(mnem, tokenizer, OPCODE_AND),
        // perf.TEQ => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.CMP => encodeDataProcessing(mnem, tokenizer, OPCODE_SUB),
        // perf.CPN => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.MOV => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.NOP => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.B   => encodeBranch(tokenizer, COND_AL),
        // perf.BEQ => encodeBranch(tokenizer, COND_EQ),
        // perf.BNE => encodeBranch(tokenizer, COND_NE),
        // perf.BCS => encodeBranch(tokenizer, COND_CS),
        // perf.BCC => encodeBranch(tokenizer, COND_CC),
        // perf.BMI => encodeBranch(tokenizer, COND_MI),
        // perf.BPL => encodeBranch(tokenizer, COND_PL),
        // perf.BVS => encodeBranch(tokenizer, COND_VS),
        // perf.BVC => encodeBranch(tokenizer, COND_VC),
        // perf.BHI => encodeBranch(tokenizer, COND_HI),
        // perf.BLS => encodeBranch(tokenizer, COND_LS),
        // perf.BGE => encodeBranch(tokenizer, COND_GE),
        // perf.BLT => encodeBranch(tokenizer, COND_LT),
        // perf.BGT => encodeBranch(tokenizer, COND_GT),
        // perf.BLE => encodeBranch(tokenizer, COND_LE),
        // perf.BL   => encodeBranch(tokenizer, FLAGS_B_L | COND_AL),
        // perf.BLEQ => encodeBranch(tokenizer, FLAGS_B_L | COND_EQ),
        // perf.BLNE => encodeBranch(tokenizer, FLAGS_B_L | COND_NE),
        // perf.BLCS => encodeBranch(tokenizer, FLAGS_B_L | COND_CS),
        // perf.BLCC => encodeBranch(tokenizer, FLAGS_B_L | COND_CC),
        // perf.BLMI => encodeBranch(tokenizer, FLAGS_B_L | COND_MI),
        // perf.BLPL => encodeBranch(tokenizer, FLAGS_B_L | COND_PL),
        // perf.BLVS => encodeBranch(tokenizer, FLAGS_B_L | COND_VS),
        // perf.BLVC => encodeBranch(tokenizer, FLAGS_B_L | COND_VC),
        // perf.BLHI => encodeBranch(tokenizer, FLAGS_B_L | COND_HI),
        // perf.BLLS => encodeBranch(tokenizer, FLAGS_B_L | COND_LS),
        // perf.BLGE => encodeBranch(tokenizer, FLAGS_B_L | COND_GE),
        // perf.BLLT => encodeBranch(tokenizer, FLAGS_B_L | COND_LT),
        // perf.BLGT => encodeBranch(tokenizer, FLAGS_B_L | COND_GT),
        // perf.BLLE => encodeBranch(tokenizer, FLAGS_B_L | COND_LE),
        perf.MVI => try encodeMoveImmediate(&tokenizer),
        perf.SWI => try encodeSoftwareInterrupt(&tokenizer),
        // perf.MOV32 =>  {
        // encodeMoveWord(tokenizer),
        // }
        else => error.Unexpected,
    } catch |err| switch (err) {
        error.Unexpected => {
            try errMsg.printError("expected mnemonic, found '{s}'\n", .{token});
            try errMsg.displayTokenInLine(&tokenizer);
            return err;
        },
        else => return err,
    };

    // Catch extraneous tokens after otherwise correct instructions
    if (tokenizer.next()) |tok| {
        try errMsg.printError("expected 'EOL', found '{s}'\n", .{tok});
        try errMsg.displayTokenInLine(&tokenizer);
        return error.Unexpected;
    }

    return Instruction{
        .encoded = encoding,
        .relocationSymbol = null,
    };
}

const fmtErrExpected = "expected {s}, found '{s}'\n";

/// Parse assembly lines beginning with LD, LDB, LSB, LDH, LDSH, ST, STB,
/// STSB, STH, and STSH mnemonics
fn encodeDataTransfer(tokenizer: *Tokenizer, flags: u32) !u32 {
    const fmtErrOffsetNotEncodable = "offset value cannot be encoded\n";
    const fmtErrShiftNotEncodable = "shift value cannot be encoded\n";

    var instr = INSTR_DATA_TRANSFER | flags;

    var postIncrement = false;
    var offsetIsRegister = false;

    const rd = try expectRegister(tokenizer);
    instr |= @as(u32, @intCast(rd)) << 24;

    _ = try expectOperator(",", tokenizer);
    _ = try expectOperator("[", tokenizer);

    const rm = try expectRegister(tokenizer);
    instr |= @as(u32, @intCast(rm)) << 20;

    switch (try expectOperator("]+-", tokenizer)) {
        '+' => {},
        '-' => instr |= FLAGS_DT_N,
        ']' => {
            if (optionalOperator("+-", tokenizer)) |c| switch (c) {
                '+' => {
                    postIncrement = true;
                    instr |= FLAGS_DT_P;
                },
                '-' => {
                    postIncrement = true;
                    instr |= FLAGS_DT_P | FLAGS_DT_N;
                },
                else => unreachable,
            } else {
                // No offset, early return
                const token = tokenizer.next() orelse return instr;
                // Extraneous token
                try errMsg.printError(fmtErrExpected, .{ "'+', '-' or 'EOL'", token });
                try errMsg.displayTokenInLine(tokenizer);
                return error.Unexpected;
            }
        },
        else => unreachable,
    }

    // Rn or #offset
    if (expectRegisterOrValue(tokenizer)) |op| switch (op) {
        .REG => |reg| {
            instr |= @as(u32, @intCast(reg));
            offsetIsRegister = true;
        },
        .IMM => |val| {
            // Immediate flag
            instr |= FLAGS_DT_I;

            if (val != 0) instr |= blk: {
                // Must determine if the value is representable as a shifted 10-bit value
                if (val <= 0x000003FF) break :blk val;
                const leadingZeros = @clz(val);
                const trailingZeros = @ctz(val);
                const windowSize = 32 - leadingZeros - trailingZeros;

                // All set bits must fit within in a 10-bit window
                if (windowSize > 10) {
                    try errMsg.printError(fmtErrOffsetNotEncodable, .{});
                    try errMsg.displayTokenInLine(tokenizer);
                    return error.ValueNotEncodable;
                }

                // If the window is not left-aligned to 2-bits, then it may only be 9-bits wide
                if (leadingZeros % 2 == 1 and windowSize == 10) {
                    try errMsg.printError(fmtErrOffsetNotEncodable, .{});
                    try errMsg.displayTokenInLine(tokenizer);
                    return error.ValueNotEncodable;
                }

                // The resulting encodable values
                const shift: u32 = trailingZeros / 2;
                const imm = val >> @intCast(shift * 2);

                break :blk shift << 11 | imm;
            };

            // Early return if closing brace already seen
            if (postIncrement) return instr;
        },
        else => unreachable,
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            try errMsg.printError(fmtErrOffsetNotEncodable, .{});
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        else => return err,
    }

    // ']' and '!' if no shift value
    if (!postIncrement) {
        if (optionalOperator("]", tokenizer)) |_| {
            if (optionalOperator("!", tokenizer)) |_| {
                instr |= FLAGS_DT_W;
            }
            return instr;
        }
    }

    if (offsetIsRegister) {
        // 'lsl'
        var token = tokenizer.next() orelse {
            // Early return if closing brace already seen
            if (postIncrement) return instr;
            // Otherwise missing closing brace
            try errMsg.printError(fmtErrExpected, .{ "']' or 'lsl'", "EOL" });
            try errMsg.displayTokenInLine(tokenizer);
            return error.EndOfLine;
        };

        const mnem = perf.parseMnemonic(token.ptr, token.len);
        switch (mnem) {
            perf.LSL => {},
            else => {
                try errMsg.printError(fmtErrExpected, .{ "'']', 'lsl', or 'EOL'", token });
                try errMsg.displayTokenInLine(tokenizer);
                return error.Unexpected;
            },
        }

        // Shift value
        token = try nextTokenNoEol("value", tokenizer);
        if (parseInteger(token)) |shift| {
            // Must determine if shift value is multiple of two and less than 32
            if ((shift & ~@as(u32, 0x0000_001E) != 0)) {
                try errMsg.printError(fmtErrShiftNotEncodable, .{});
                try errMsg.displayTokenInLine(tokenizer);
                return error.ValueNotEncodable;
            }
            instr |= shift << 10;
        } else |err| switch (err) {
            error.ValueNotEncodable => {
                try errMsg.printError(fmtErrShiftNotEncodable, .{});
                try errMsg.displayTokenInLine(tokenizer);
                return err;
            },
            error.Unexpected => {
                try errMsg.printError(fmtErrExpected, .{ "value", token });
                try errMsg.displayTokenInLine(tokenizer);
                return err;
            },
            else => return err,
        }
    }

    // Early return if closing brace already seen
    if (postIncrement) return instr;

    _ = try expectOperator("]", tokenizer);
    _ = optionalOperator("!", tokenizer) orelse return instr;

    return instr | FLAGS_DT_W;
}

/// Parse assembly lines beginning with SMV mnemonic
fn encodeMoveFromPsr(tokenizer: *Tokenizer) !u32 {
    const instr = INSTR_MOVE_FROM_PSR;

    const rd = try expectRegister(tokenizer);
    return instr | (@as(u32, @intCast(rd)) << 24);
}

/// Parse assembly lines beginning with SMV mnemonic
fn encodeSetClearPsrBits(tokenizer: *Tokenizer, flags: u32) !u32 {
    const fmtErrNotEncodable = "value cannot be encoded\n";

    var instr = INSTR_SET_CLEAR_PSR_BITS | flags;

    const rd = try expectRegister(tokenizer);
    instr |= (@as(u32, @intCast(rd)) << 24);

    // Rn or #offset
    if (expectRegisterOrValue(tokenizer)) |op| switch (op) {
        .REG => |reg| instr |= reg,
        .IMM => |val| {
            // Must determine if the value is representable in 10-bits
            if (val > 0x0000_03FF) {
                try errMsg.printError(fmtErrNotEncodable, .{});
                try errMsg.displayTokenInLine(tokenizer);
                return error.ValueNotEncodable;
            }

            instr |= FLAGS_PSR_I | val;
        },
        else => unreachable,
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            try errMsg.printError(fmtErrNotEncodable, .{});
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        else => return err,
    }

    return instr;
}

/// Parse assembly lines beginning with MVI mnemonic
fn encodeMoveImmediate(tokenizer: *Tokenizer) !u32 {
    const fmtErrNotEncodable = "value cannot be encoded by MVI, use MOV32 instead\n";

    var instr = INSTR_MOVE_IMMEDIATE;

    var negate = false;

    const rd = try expectRegister(tokenizer);
    instr |= @as(u32, @intCast(rd)) << 24;

    _ = try expectOperator(",", tokenizer);

    // Optional '-'
    if (optionalOperator("-", tokenizer)) |_| {
        negate = true;
        instr |= FLAGS_MI_M;
    }

    // Immediate value
    const token = try nextTokenNoEol("value", tokenizer);
    if (parseInteger(token)) |imm| {
        if (negate) {
            const immNeg = ~imm + 1;
            if (immNeg < 0xFF00_0000) {
                try errMsg.printError(fmtErrNotEncodable, .{});
                if (negate) tokenizer.tokenStart -= 1; // underline '-' as well
                try errMsg.displayTokenInLine(tokenizer);
                return error.ValueNotEncodable;
            }

            return instr | (immNeg & 0x00FF_FFFF);
        }

        if (imm & 0xFF00_0000 == 0xFF00_0000) {
            // positive value with 8 highest bits set
            instr |= FLAGS_MI_M;
        } else if (imm > 0x00FF_FFFF) {
            try errMsg.printError(fmtErrNotEncodable, .{});
            if (negate) tokenizer.tokenStart -= 1; // underline '-' as well
            try errMsg.displayTokenInLine(tokenizer);
            return error.ValueNotEncodable;
        }

        return instr | (imm & 0x00FF_FFFF);
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            try errMsg.printError(fmtErrNotEncodable, .{});
            if (negate) tokenizer.tokenStart -= 1; // underline '-' as well
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        error.Unexpected => {
            try errMsg.printError(fmtErrExpected, .{ "value", token });
            if (negate) tokenizer.tokenStart -= 1; // underline '-' as well
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
    }
}

/// Parse assembly lines beginning with SWI mnemonic
fn encodeSoftwareInterrupt(tokenizer: *Tokenizer) !u32 {
    const instr = INSTR_SOFTWARE_INTERRUPT;

    const token = tokenizer.next() orelse return instr;
    const comment = parseInteger(token) catch |err| switch (err) {
        error.Unexpected => {
            try errMsg.printError(fmtErrExpected, .{ "positive value", token });
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        error.ValueNotEncodable => {
            try errMsg.printError("comment value cannot be encoded", .{});
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
    };

    if ((comment & ~@as(u32, 0x0FFF_FFFF)) != 0) {
        try errMsg.printError("comment value cannot be encoded", .{});
        try errMsg.displayTokenInLine(tokenizer);
        return error.ValueNotEncodable;
    }

    return instr | comment;
}

// ================================================================
//   PARSING HELPER FUNCTIONS
// ================================================================

const LineError = error{EndOfLine};

inline fn nextTokenNoEol(comptime expect: []const u8, tokenizer: *Tokenizer) ![]const u8 {
    if (tokenizer.next()) |token| {
        return token;
    } else {
        try errMsg.printError(fmtErrExpected, .{ expect, "EOL" });
        try errMsg.displayTokenInLine(tokenizer);
        return error.EndOfLine;
    }
}

inline fn expectRegister(tokenizer: *Tokenizer) !u4 {
    const token = try nextTokenNoEol("register", tokenizer);
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| return reg,
        else => {
            try errMsg.printError(fmtErrExpected, .{ "register", token });
            try errMsg.displayTokenInLine(tokenizer);
            return error.Unexpected;
        },
    } else |err| switch (err) {
        error.Unexpected => {
            try errMsg.printError(fmtErrExpected, .{ "register", token });
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        else => return err,
    }
}

inline fn expectRegisterOrValue(tokenizer: *Tokenizer) !Operand {
    const token = try nextTokenNoEol("register or value", tokenizer);
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| return Operand{ .REG = reg },
        .IMM => |imm| return Operand{ .IMM = imm },
        else => {
            try errMsg.printError(fmtErrExpected, .{ "register or value", token });
            try errMsg.displayTokenInLine(tokenizer);
            return error.Unexpected;
        },
    } else |err| switch (err) {
        error.Unexpected => {
            try errMsg.printError(fmtErrExpected, .{ "register or value", token });
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        else => return err,
    }
}

inline fn expectOperator(comptime expect: []const u8, tokenizer: *Tokenizer) !u8 {
    // Operator list fomatted for error message
    const expectListString = comptime errMsg.operatorListStr(expect);

    const token = try nextTokenNoEol(expectListString, tokenizer);
    inline for (expect) |c| if (token[0] == c) return c;

    try errMsg.printError(fmtErrExpected, .{ expectListString, token });
    try errMsg.displayTokenInLine(tokenizer);
    return error.Unexpected;
}

inline fn optionalOperator(comptime expect: []const u8, tokenizer: *Tokenizer) ?u8 {
    const token = tokenizer.next() orelse return null;
    inline for (expect) |c| if (token[0] == c) return c;

    tokenizer.putBack();
    return null;
}

const OperandTag = enum { REG, IMM, LABEL };
const Operand = union(OperandTag) { REG: u4, IMM: u32, LABEL: []const u8 };

const OperandError = error{ Unexpected, ValueNotEncodable };

fn parseOperand(token: []const u8) !Operand {
    switch (token[0]) {
        'r', 'R' => {
            if (token.len > 3) return error.Unexpected;
            const regNum = try parseDec(token[1..]);
            if (regNum > 0b1111) return error.Unexpected;
            return Operand{ .REG = @intCast(regNum) };
        },
        's' => {
            if (token.len == 2 and token[1] == 'p') return Operand{ .REG = 0b1110 };
            return error.Unexpected;
        },
        'S' => {
            if (token.len == 2 and token[1] == 'P') return Operand{ .REG = 0b1110 };
            return error.Unexpected;
        },
        'l' => {
            if (token.len == 2 and token[1] == 'r') return Operand{ .REG = 0b1111 };
            return error.Unexpected;
        },
        'L' => {
            if (token.len == 2 and token[1] == 'R') return Operand{ .REG = 0b1111 };
            return error.Unexpected;
        },
        '0' => {
            if (token.len < 3) return error.Unexpected;
            if (token[1] == 'x') return Operand{ .IMM = try parseHex(token[2..]) };
            if (token[1] == 'b') return Operand{ .IMM = try parseBin(token[2..]) };
            return error.Unexpected;
        },
        else => {
            if (ascii.isDigit(token[0])) return Operand{ .IMM = try parseDec(token) };
            return Operand{ .LABEL = token };
        },
    }
}

inline fn parseInteger(token: []const u8) !u32 {
    switch (token[0]) {
        '0' => {
            if (token.len < 3) return error.Unexpected;
            if (token[1] == 'x') return try parseHex(token[2..]);
            if (token[1] == 'b') return try parseBin(token[2..]);
            return error.Unexpected;
        },
        else => {
            if (ascii.isDigit(token[0])) return try parseDec(token);
            return error.Unexpected;
        },
    }
}

inline fn parseDec(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val *= 10;
        val += try u8AsDec(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsDec(c: u8) !u4 {
    if (c >= '0' and c <= '9') return @intCast(c - '0');
    return error.Unexpected;
}

inline fn parseHex(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val <<= 4;
        val += try u8AsHex(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsHex(c: u8) !u4 {
    if (c >= '0' and c <= '9') return @intCast(c - '0');
    if (c >= 'A' and c <= 'F') return @intCast(c - 'A' + 10);
    if (c >= 'a' and c <= 'f') return @intCast(c - 'a' + 10);
    return error.Unexpected;
}

inline fn parseBin(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val <<= 1;
        val += try u8AsBin(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsBin(c: u8) !u1 {
    if (c == '0' or c == '1') return @intCast(c - '0');
    return error.Unexpected;
}

// ================================================================
//   TESTS
// ================================================================

/// Unwraps Instruction returns from encodeInstruction into raw u32 encodings
fn ENCODE(line: [:0]const u8) !u32 {
    const instr = try encodeInstruction(line) orelse Instruction{ .encoded = 0, .relocationSymbol = null };
    return instr.encoded;
}

test "Empty lines" {
    try std.testing.expectEqual(null, try encodeInstruction(""));
    try std.testing.expectEqual(null, try encodeInstruction("; some comment"));
}

test "Invalid mnemonic" {
    try std.testing.expectError(error.Unexpected, encodeInstruction("    bad"));
}

// --- Data Transfer Instructions

test "Data Transfer -- Unexpected EOL" {
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1,"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, ["));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2 +"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2 -"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2 + 4"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2 + r3"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2 + r3 lsl"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2 + r3 lsl 4"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2] +"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2] -"));
    try std.testing.expectError(error.EndOfLine, encodeInstruction("    ld r1, [r2] + r3 lsl"));
}

test "Data Transfer -- Unexpected token" {
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1,!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2 +!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2 -!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2 + 4!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2 + 4 lsl"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2 + r3!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2 + r3 lsl!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2 + r3 lsl 4!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2] +!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2] -!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2] + r3 lsl!"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2] + 4 lsl"));
    try std.testing.expectError(error.Unexpected, encodeInstruction("    ld r1, [r2]!"));
}

test "Data Transfer -- Unencodable #offset" {
    try std.testing.expectError(error.ValueNotEncodable, encodeInstruction("    ld r1, [r2 + 0b1111_1111_111]"));
    try std.testing.expectError(error.ValueNotEncodable, encodeInstruction("    ld r1, [r2] + 0b1111_1111_111"));
    try std.testing.expectError(error.ValueNotEncodable, encodeInstruction("    ld r1, [r2 + 0b1111_1111_110]"));
    try std.testing.expectError(error.ValueNotEncodable, encodeInstruction("    ld r1, [r2] + 0b1111_1111_110"));
}

test "Data Transfer -- Unencodable #shift" {
    try std.testing.expectError(error.ValueNotEncodable, encodeInstruction("    ld r1, [r2 + r3 lsl 1]"));
    try std.testing.expectError(error.ValueNotEncodable, encodeInstruction("    ld r1, [r2 + r3 lsl 32]"));
}

test "Data transfer -- Mnemonic variants" {
    try std.testing.expectEqual(0x0120_0000, try ENCODE("    ld    r1, [r2]"));
    try std.testing.expectEqual(0x0120_8000, try ENCODE("    ldb   r1, [r2]"));
    try std.testing.expectEqual(0x0120_8400, try ENCODE("    ldsb  r1, [r2]"));
    try std.testing.expectEqual(0x0121_0000, try ENCODE("    ldh   r1, [r2]"));
    try std.testing.expectEqual(0x0121_0400, try ENCODE("    ldsh  r1, [r2]"));
    try std.testing.expectEqual(0x2120_0000, try ENCODE("    st    r1, [r2]"));
    try std.testing.expectEqual(0x2120_8000, try ENCODE("    stb   r1, [r2]"));
    try std.testing.expectEqual(0x2120_8400, try ENCODE("    stsb  r1, [r2]"));
    try std.testing.expectEqual(0x2121_0000, try ENCODE("    sth   r1, [r2]"));
    try std.testing.expectEqual(0x2121_0400, try ENCODE("    stsh  r1, [r2]"));
}

test "Data transfer -- no writeback register offset" {
    try std.testing.expectEqual(0x0120_0003, try ENCODE("    ld    r1, [r2 + r3]"));
    try std.testing.expectEqual(0x0124_0003, try ENCODE("    ld    r1, [r2 - r3]"));
    try std.testing.expectEqual(0x0120_1003, try ENCODE("    ld    r1, [r2 + r3 lsl 4]"));
    try std.testing.expectEqual(0x0124_1003, try ENCODE("    ld    r1, [r2 - r3 lsl 4]"));
}

test "Data transfer -- no writeback immediate" {
    try std.testing.expectEqual(0x1120_02AA, try ENCODE("    ld    r1, [r2 + 0x02AA]"));
    try std.testing.expectEqual(0x1124_02AA, try ENCODE("    ld    r1, [r2 - 0x02AA]"));
}

test "Data transfer -- pre-increment register offset" {
    try std.testing.expectEqual(0x0122_0003, try ENCODE("    ld    r1, [r2 + r3]!"));
    try std.testing.expectEqual(0x0126_0003, try ENCODE("    ld    r1, [r2 - r3]!"));
    try std.testing.expectEqual(0x0122_1003, try ENCODE("    ld    r1, [r2 + r3 lsl 4]!"));
    try std.testing.expectEqual(0x0126_1003, try ENCODE("    ld    r1, [r2 - r3 lsl 4]!"));
}

test "Data transfer -- pre-increment writeback immediate" {
    try std.testing.expectEqual(0x1122_02AA, try ENCODE("    ld    r1, [r2 + 0x02AA]!"));
    try std.testing.expectEqual(0x1126_02AA, try ENCODE("    ld    r1, [r2 - 0x02AA]!"));
}

test "Data transfer -- post-increment register offset" {
    try std.testing.expectEqual(0x0128_0003, try ENCODE("    ld    r1, [r2] + r3"));
    try std.testing.expectEqual(0x012C_0003, try ENCODE("    ld    r1, [r2] - r3"));
    try std.testing.expectEqual(0x0128_1003, try ENCODE("    ld    r1, [r2] + r3 lsl 4"));
    try std.testing.expectEqual(0x012C_1003, try ENCODE("    ld    r1, [r2] - r3 lsl 4"));
}

test "Data transfer -- post-increment writeback immediate" {
    try std.testing.expectEqual(0x1128_02AA, try ENCODE("    ld    r1, [r2] + 0x02AA"));
    try std.testing.expectEqual(0x112C_02AA, try ENCODE("    ld    r1, [r2] - 0x02AA"));
}

test "Data transfer -- implicitly shifted immediate" {
    try std.testing.expectEqual(0x1120_12AA, try ENCODE("    ld    r1, [r2 + 0x2AA0]"));
    try std.testing.expectEqual(0x1120_2851, try ENCODE("    ld    r1, [r2 + 0x14400]"));
    try std.testing.expectEqual(0x1120_1992, try ENCODE("    ld    r1, [r2 + 0x6480]"));
    try std.testing.expectEqual(0x1120_2341, try ENCODE("    ld    r1, [r2 + 0x34100]"));
}

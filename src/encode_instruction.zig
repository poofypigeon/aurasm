const std = @import("std");
const ascii = std.ascii;

const Tokenizer = @import("tokenizer.zig").Tokenizer;

const errMsg = @import("error_message.zig");

const perf = @cImport(@cInclude("parse_mnemonic.c"));

const Instruction = struct {
    encoded: u32,
    relocationSymbol: ?[]u8,
};

// ================================================================
//   INSTRUCTION ENCODINGS AND FLAGS
// ================================================================

const INSTR_DATA_TRANSFER: u32 = 0x0000_0000;
const FLAGS_DT_S: u32 = 1 << 29;
const FLAGS_DT_I: u32 = 1 << 28;
const FLAGS_DT_P: u32 = 1 << 19;
const FLAGS_DT_N: u32 = 1 << 18;
const FLAGS_DT_W: u32 = 1 << 17;
const FLAGS_DT_H: u32 = 1 << 16;
const FLAGS_DT_B: u32 = 1 << 15;
const FLAGS_DT_M: u32 = 1 << 10;

const INSTR_MOVE_FROM_PSR: u32 = 0x0001_8000;

const INSTR_SET_CLEAR_PSR_BITS: u32 = 0x2001_8000;
const FLAGS_PSR_S: u32 = 1 << 17;

const INSTR_DATA_PROCESSING: u32 = 0x4000_0000;

const INSTR_BRANCH: u32 = 0x8000_0000;
const FLAGS_B_L: u32 = 1 << 29;
const COND_EQ: u32 = 0b0000 << 17;
const COND_NE: u32 = 0b0001 << 17;
const COND_CS: u32 = 0b0010 << 17;
const COND_CC: u32 = 0b0011 << 17;
const COND_MI: u32 = 0b0100 << 17;
const COND_PL: u32 = 0b0101 << 17;
const COND_VS: u32 = 0b0110 << 17;
const COND_VC: u32 = 0b0111 << 17;
const COND_HI: u32 = 0b1000 << 17;
const COND_LS: u32 = 0b1001 << 17;
const COND_GE: u32 = 0b1010 << 17;
const COND_LT: u32 = 0b1011 << 17;
const COND_GT: u32 = 0b1100 << 17;
const COND_LE: u32 = 0b1101 << 17;
const COND_AL: u32 = 0b1110 << 17;

const INSTR_MOVE_IMMEDIATE: u32 = 0xC000_0000;
const FLAGS_MI_M: u32 = 1 << 28;

const InstructionError = error{InvalidMnemonic};

// ================================================================
//   INSTRUCTION PARSING
// ================================================================

pub fn encodeInstruction(line: [:0]const u8) !?Instruction {
    var tokenizer = Tokenizer.init(line);
    const token = tokenizer.next() catch return null;

    // Line is only a comment
    if (token[0] == ';') return null;

    // Resolve mnemonic using perfect hash generated by gperf
    const mnem = perf.parseMnemonic(token.ptr, token.len);
    const encoding = switch (mnem) {
        perf.LD => try encodeDataTransfer(&tokenizer, 0),
        perf.LDB => try encodeDataTransfer(&tokenizer, FLAGS_DT_B),
        perf.LDSB => try encodeDataTransfer(&tokenizer, FLAGS_DT_B | FLAGS_DT_M),
        perf.LDH => try encodeDataTransfer(&tokenizer, FLAGS_DT_H),
        perf.LDSH => try encodeDataTransfer(&tokenizer, FLAGS_DT_H | FLAGS_DT_M),
        perf.ST => try encodeDataTransfer(&tokenizer, FLAGS_DT_S),
        perf.STB => try encodeDataTransfer(&tokenizer, FLAGS_DT_S | FLAGS_DT_B),
        perf.STSB => try encodeDataTransfer(&tokenizer, FLAGS_DT_S | FLAGS_DT_B | FLAGS_DT_M),
        perf.STH => try encodeDataTransfer(&tokenizer, FLAGS_DT_S | FLAGS_DT_H),
        perf.STSH => try encodeDataTransfer(&tokenizer, FLAGS_DT_S | FLAGS_DT_H | FLAGS_DT_M),
        // perf.SMV => encodeMoveFromPsr(tokenizer),
        // perf.SST => encodeSetClearPsrBits(tokenizer, FLAGS_PSR_S),
        // perf.SCL => encodeSetClearPsrBits(tokenizer, 0),
        // perf.ADD => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.ADC => encodeDataProcessing(mnem, tokenizer, OPCODE_ADC),
        // perf.SUB => encodeDataProcessing(mnem, tokenizer, OPCODE_SUB),
        // perf.SBC => encodeDataProcessing(mnem, tokenizer, OPCODE_SBC),
        // perf.AND => encodeDataProcessing(mnem, tokenizer, OPCODE_AND),
        // perf.OR => encodeDataProcessing(mnem, tokenizer, OPCODE_OR),
        // perf.XOR => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.BTC => encodeDataProcessing(mnem, tokenizer, OPCODE_BTC),
        // perf.NOT => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.ADDX => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.ADCX => encodeDataProcessing(mnem, tokenizer, OPCODE_ADC),
        // perf.SUBX => encodeDataProcessing(mnem, tokenizer, OPCODE_SUB),
        // perf.SBCX => encodeDataProcessing(mnem, tokenizer, OPCODE_SBC),
        // perf.ANDX => encodeDataProcessing(mnem, tokenizer, OPCODE_AND),
        // perf.ORX => encodeDataProcessing(mnem, tokenizer, OPCODE_OR),
        // perf.XORX => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.BTCX => encodeDataProcessing(mnem, tokenizer, OPCODE_BTC),
        // perf.NOTX => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.LSL => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.LSR => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.ASR => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.LSLX => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.TST => encodeDataProcessing(mnem, tokenizer, OPCODE_AND),
        // perf.TEQ => encodeDataProcessing(mnem, tokenizer, OPCODE_XOR),
        // perf.CMP => encodeDataProcessing(mnem, tokenizer, OPCODE_SUB),
        // perf.CPN => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.MOV => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.NOP => encodeDataProcessing(mnem, tokenizer, OPCODE_ADD),
        // perf.B   => encodeBranch(tokenizer, COND_AL),
        // perf.BEQ => encodeBranch(tokenizer, COND_EQ),
        // perf.BNE => encodeBranch(tokenizer, COND_NE),
        // perf.BCS => encodeBranch(tokenizer, COND_CS),
        // perf.BCC => encodeBranch(tokenizer, COND_CC),
        // perf.BMI => encodeBranch(tokenizer, COND_MI),
        // perf.BPL => encodeBranch(tokenizer, COND_PL),
        // perf.BVS => encodeBranch(tokenizer, COND_VS),
        // perf.BVC => encodeBranch(tokenizer, COND_VC),
        // perf.BHI => encodeBranch(tokenizer, COND_HI),
        // perf.BLS => encodeBranch(tokenizer, COND_LS),
        // perf.BGE => encodeBranch(tokenizer, COND_GE),
        // perf.BLT => encodeBranch(tokenizer, COND_LT),
        // perf.BGT => encodeBranch(tokenizer, COND_GT),
        // perf.BLE => encodeBranch(tokenizer, COND_LE),
        // perf.BL   => encodeBranch(tokenizer, FLAGS_B_L | COND_AL),
        // perf.BLEQ => encodeBranch(tokenizer, FLAGS_B_L | COND_EQ),
        // perf.BLNE => encodeBranch(tokenizer, FLAGS_B_L | COND_NE),
        // perf.BLCS => encodeBranch(tokenizer, FLAGS_B_L | COND_CS),
        // perf.BLCC => encodeBranch(tokenizer, FLAGS_B_L | COND_CC),
        // perf.BLMI => encodeBranch(tokenizer, FLAGS_B_L | COND_MI),
        // perf.BLPL => encodeBranch(tokenizer, FLAGS_B_L | COND_PL),
        // perf.BLVS => encodeBranch(tokenizer, FLAGS_B_L | COND_VS),
        // perf.BLVC => encodeBranch(tokenizer, FLAGS_B_L | COND_VC),
        // perf.BLHI => encodeBranch(tokenizer, FLAGS_B_L | COND_HI),
        // perf.BLLS => encodeBranch(tokenizer, FLAGS_B_L | COND_LS),
        // perf.BLGE => encodeBranch(tokenizer, FLAGS_B_L | COND_GE),
        // perf.BLLT => encodeBranch(tokenizer, FLAGS_B_L | COND_LT),
        // perf.BLGT => encodeBranch(tokenizer, FLAGS_B_L | COND_GT),
        // perf.BLLE => encodeBranch(tokenizer, FLAGS_B_L | COND_LE),
        perf.MVI => try encodeMoveImmediate(&tokenizer),
        // perf.SWI => encodeSoftwareInterrups(tokenizer),
        // perf.MOV32 => encodeMoveWord(tokenizer),
        else => error.InvalidMnemonic,
    } catch |err| switch (err) {
        error.InvalidMnemonic => {
            try errMsg.printError("expected mnemonic, found '{s}'\n", .{token});
            try errMsg.displayTokenInLine(&tokenizer);
            return err;
        },
        else => return err,
    };

    // Catch extraneous tokens after otherwise correct instructions
    if (tokenizer.next()) |tok| {
        try errMsg.printError("expected 'EOL', found '{s}'\n", .{tok});
        try errMsg.displayTokenInLine(&tokenizer);
        return error.Unexpected;
    } else |err| switch (err) {
        error.EndOfTokens => {},
        else => return err,
    }

    return Instruction{
        .encoded = encoding,
        .relocationSymbol = null,
    };
}

const fmtErrExpected = "expected {s}, found '{s}'\n";

fn encodeDataTransfer(tokenizer: *Tokenizer, flags: u32) !u32 {
    var instr = INSTR_DATA_TRANSFER | flags;

    var postIncrement = false;

    const rd = try expectRegister(tokenizer);
    instr |= @as(u32, @intCast(rd)) << 24;

    _ = try expectOperator(",", tokenizer);
    _ = try expectOperator("[", tokenizer);

    const rm = try expectRegister(tokenizer);
    instr |= @as(u32, @intCast(rm)) << 20;

    switch (try expectOperator("]+-", tokenizer)) {
        '+' => {},
        '-' => instr |= FLAGS_DT_N,
        ']' => {
            if (optionalOperator("+-", tokenizer)) |res| {
                if (res) |c| switch (c) {
                    '+' => {
                        postIncrement = true;
                        instr |= FLAGS_DT_P;
                    },
                    '-' => {
                        postIncrement = true;
                        instr |= FLAGS_DT_P | FLAGS_DT_N;
                    },
                    else => unreachable,
                };
            } else |err| switch (err) {
                // No offset, early return
                error.EndOfTokens => return instr,
                else => return err,
            }
        },
        else => unreachable,
    }

    // Rn or #offset
    if (expectRegisterOrValue(tokenizer)) |op| switch (op) {
        .REG => |reg| instr |= @as(u32, @intCast(reg)),
        .IMM => |val| {
            // Immediate flag
            instr |= FLAGS_DT_I;

            if (val != 0) instr |= blk: {
                // Must determine if the value is representable as a shifted 10-bit value
                if (val <= 0x000003FF) break :blk val;
                std.debug.print("here2\n", .{});
                const leadingZeros = @clz(val);
                const trailingZeros = @ctz(val);
                const windowSize = 32 - leadingZeros - trailingZeros;

                // All set bits must fit within in a 10-bit window
                if (windowSize > 10) {
                    // TODO error message
                    return error.ValueNotEncodable;
                }

                // If the window is not left-aligned to 2-bits, then it may only be 9-bits wide
                if (leadingZeros % 2 == 1 and windowSize == 10) {
                    // TODO error message
                    return error.ValueNotEncodable;
                }

                // The resulting encodable values
                const shift: u32 = leadingZeros / 2;
                const imm = val >> @intCast(shift * 2);

                break :blk shift << 11 | imm;
            };

            // Early return if closing brace already seen
            if (postIncrement) return instr;
        },
        else => unreachable,
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            // TODO error message
            return err;
        },
        else => return err,
    }

    // ']' and '!' if no shift value
    if (!postIncrement) {
        const noShift = optionalOperator("]", tokenizer) catch |err| switch (err) {
            error.EndOfTokens => {
                try errMsg.printError(fmtErrExpected, .{ "'['", "EOL" });
                try errMsg.displayTokenInLine(tokenizer);
                return err;
            },
            else => return err,
        };
        if (noShift) |_| {
            if (optionalOperator("!", tokenizer)) |preIncrement| {
                if (preIncrement) |_| return instr | FLAGS_DT_W;
            } else |err| switch (err) {
                error.EndOfTokens => {},
                else => return err,
            }
        }
    }

    // 'lsl'
    var token = tokenizer.next() catch |err| switch (err) {
        // No shift on offset, early return
        error.EndOfTokens => return instr,
        else => return err,
    };
    const mnem = perf.parseMnemonic(token.ptr, token.len);
    switch (mnem) {
        perf.LSL => {},
        else => {
            try errMsg.printError(fmtErrExpected, .{ "'lsl'", token });
            try errMsg.displayTokenInLine(tokenizer);
            return error.Unexpected;
        },
    }

    // Shift value
    token = try nextTokenNoEol("value", tokenizer);
    if (parseInteger(token)) |shift| {
        // Must determine if shift value is multiple of two and less than 32
        if ((shift & ~@as(u32, 0x0000_001E) != 0)) {
            try errMsg.printError("shift value cannot be encoded\n", .{});
            try errMsg.displayTokenInLine(tokenizer);
            return error.ValueNotEncodable;
        }
        instr |= shift << 10;
        return instr;
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            try errMsg.printError("shift value cannot be encoded\n", .{});
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        else => return err,
    }

    // Early return if closing brace already seen
    if (postIncrement) return instr;

    try expectOperator("]", tokenizer);
    optionalOperator("!", tokenizer) catch |err| switch (err) {
        // No pre-increment
        error.EndOfTokens => return instr,
        else => return err,
    };

    return instr | FLAGS_DT_W;
}

fn encodeMoveImmediate(tokenizer: *Tokenizer) !u32 {
    const fmtErrNotEncodable = "value cannot be encoded by MVI, use MOV32 instead\n";

    var instr = INSTR_MOVE_IMMEDIATE;

    var negate = false;

    const reg = try expectRegister(tokenizer);
    instr |= @as(u32, @intCast(reg)) << 24;

    _ = try expectOperator(",", tokenizer);

    // Optional '-'
    if (try optionalOperator("-", tokenizer)) |_| {
        negate = true;
        instr |= FLAGS_MI_M;
    }

    // Immediate value
    const token = try nextTokenNoEol("value", tokenizer);
    if (parseInteger(token)) |imm| {
        if (negate) {
            const immNeg = ~imm + 1;
            if (immNeg < 0xFF00_0000) {
                try errMsg.printError(fmtErrNotEncodable, .{});
                if (negate) tokenizer.tokenStart -= 1; // underline '-' as well
                try errMsg.displayTokenInLine(tokenizer);
                return error.ValueNotEncodable;
            }

            return instr | (immNeg & 0x00FF_FFFF);
        }

        if (imm & 0xFF00_0000 == 0xFF00_0000) {
            // positive value with 8 highest bits set
            instr |= FLAGS_MI_M;
        } else if (imm > 0x00FF_FFFF) {
            try errMsg.printError(fmtErrNotEncodable, .{});
            if (negate) tokenizer.tokenStart -= 1; // underline '-' as well
            try errMsg.displayTokenInLine(tokenizer);
            return error.ValueNotEncodable;
        }

        return instr | (imm & 0x00FF_FFFF);
    } else |err| switch (err) {
        error.ValueNotEncodable => {
            try errMsg.printError(fmtErrNotEncodable, .{});
            if (negate) tokenizer.tokenStart -= 1; // underline '-' as well
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        error.InvalidOperand => {
            try errMsg.printError(fmtErrExpected, .{ "value", token });
            if (negate) tokenizer.tokenStart -= 1; // underline '-' as well
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
    }
}

// ================================================================
//   PARSING HELPER FUNCTIONS
// ================================================================

inline fn nextTokenNoEol(comptime expect: []const u8, tokenizer: *Tokenizer) ![]const u8 {
    return tokenizer.next() catch |err| switch (err) {
        error.EndOfTokens => {
            try errMsg.printError(fmtErrExpected, .{ expect, "EOL" });
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
    };
}

inline fn expectRegister(tokenizer: *Tokenizer) !u4 {
    const token = try nextTokenNoEol("register", tokenizer);
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| return reg,
        else => {
            try errMsg.printError(fmtErrExpected, .{ "register", token });
            try errMsg.displayTokenInLine(tokenizer);
            return error.Unexpected;
        },
    } else |err| switch (err) {
        error.InvalidOperand => {
            try errMsg.printError(fmtErrExpected, .{ "register", token });
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        else => return err,
    }
}

inline fn expectRegisterOrValue(tokenizer: *Tokenizer) !Operand {
    const token = try nextTokenNoEol("register or value", tokenizer);
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| return Operand{ .REG = reg },
        .IMM => |imm| return Operand{ .IMM = imm },
        else => {
            try errMsg.printError(fmtErrExpected, .{ "register or value", token });
            try errMsg.displayTokenInLine(tokenizer);
            return error.Unexpected;
        },
    } else |err| switch (err) {
        error.InvalidOperand => {
            try errMsg.printError(fmtErrExpected, .{ "register or value", token });
            try errMsg.displayTokenInLine(tokenizer);
            return err;
        },
        else => return err,
    }
}

inline fn expectOperator(comptime expect: []const u8, tokenizer: *Tokenizer) !u8 {
    // Operator list fomatted for error message
    const expectListString = comptime errMsg.operatorListStr(expect);

    const token = try nextTokenNoEol(expectListString, tokenizer);
    inline for (expect) |c| if (token[0] == c) return c;

    try errMsg.printError(fmtErrExpected, .{ expectListString, token });
    try errMsg.displayTokenInLine(tokenizer);
    return error.Unexpected;
}

inline fn optionalOperator(comptime expect: []const u8, tokenizer: *Tokenizer) !?u8 {
    const token = try tokenizer.next();
    inline for (expect) |c| if (token[0] == c) return c;

    tokenizer.putBack();
    return null;
}

const OperandTag = enum { REG, IMM, LABEL };
const Operand = union(OperandTag) { REG: u4, IMM: u32, LABEL: []const u8 };

const OperandError = error{ InvalidOperand, ValueNotEncodable };

fn parseOperand(token: []const u8) !Operand {
    switch (token[0]) {
        'r', 'R' => {
            if (token.len > 3) return error.InvalidOperand;
            const regNum = try parseDec(token[1..]);
            if (regNum > 0b1111) return error.InvalidOperand;
            return Operand{ .REG = @intCast(regNum) };
        },
        's' => {
            if (token.len == 2 and token[1] == 'p') return Operand{ .REG = 0b1110 };
            return error.InvalidOperand;
        },
        'S' => {
            if (token.len == 2 and token[1] == 'P') return Operand{ .REG = 0b1110 };
            return error.InvalidOperand;
        },
        'l' => {
            if (token.len == 2 and token[1] == 'r') return Operand{ .REG = 0b1111 };
            return error.InvalidOperand;
        },
        'L' => {
            if (token.len == 2 and token[1] == 'R') return Operand{ .REG = 0b1111 };
            return error.InvalidOperand;
        },
        '0' => {
            if (token.len < 3) return error.InvalidOperand;
            if (token[1] == 'x') return Operand{ .IMM = try parseHex(token[2..]) };
            if (token[1] == 'b') return Operand{ .IMM = try parseBin(token[2..]) };
            return error.InvalidOperand;
        },
        else => {
            if (ascii.isDigit(token[0])) return Operand{ .IMM = try parseDec(token) };
            return Operand{ .LABEL = token };
        },
    }
}

inline fn parseInteger(token: []const u8) !u32 {
    switch (token[0]) {
        '0' => {
            if (token.len < 3) return error.InvalidOperand;
            if (token[1] == 'x') return try parseHex(token[2..]);
            if (token[1] == 'b') return try parseBin(token[2..]);
            return error.InvalidOperand;
        },
        else => {
            if (ascii.isDigit(token[0])) return try parseDec(token);
            return error.InvalidOperand;
        },
    }
}

inline fn parseDec(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val *= 10;
        val += try u8AsDec(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsDec(c: u8) !u4 {
    if (c >= '0' and c <= '9') return @intCast(c - '0');
    return error.InvalidOperand;
}

inline fn parseHex(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val <<= 4;
        val += try u8AsHex(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsHex(c: u8) !u4 {
    if (c >= '0' and c <= '9') return @intCast(c - '0');
    if (c >= 'A' and c <= 'F') return @intCast(c - 'A' + 10);
    if (c >= 'a' and c <= 'f') return @intCast(c - 'a' + 10);
    return error.InvalidOperand;
}

inline fn parseBin(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val <<= 1;
        val += try u8AsBin(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsBin(c: u8) !u1 {
    if (c == '0' or c == '1') return @intCast(c - '0');
    return error.InvalidOperand;
}

// ================================================================
//   TESTS
// ================================================================

const globals = @import("globals.zig");

fn parseInstr(line: [:0]const u8) !void {
    if (encodeInstruction(line)) |o| {
        if (o) |instr| {
            std.debug.print("{s}\n\tencoded value: {x:0>8}\n", .{ line, instr.encoded });
        } else {
            std.debug.print("empty line.\n", .{});
        }
    } else |err| switch (err) {
        else => {},
    }
}

test {
    try globals.path.appendSlice("testing.s");
    try parseInstr("    ld r3, [r1]");
    try parseInstr("    ldb r3, [r1]");
    try parseInstr("    ldsb r3, [r1]");
    try parseInstr("    ldh r3, [r1]");
    try parseInstr("    ldsh r3, [r1]");
    try parseInstr("    LD r3, [r1]");
    try parseInstr("    LDB r3, [r1]");
    try parseInstr("    LDSB r3, [r1]");
    try parseInstr("    LDH r3, [r1]");
    try parseInstr("    LDSH r3, [r1]");

    try parseInstr("    ld r3, [r1 + 4]");
    try parseInstr("    ld r3, [r1 + 4] lsl 8");
    try parseInstr("    ld r3, [r1 + 4 lsl 8]");

    // try parseInstr("    ld r3 [r1]");
    // try parseInstr("    ld r3, r1]");
    // try parseInstr("    ld r3, []");
}

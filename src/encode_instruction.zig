const std = @import("std");
const ascii = std.ascii;

const Tokenizer = @import("tokenizer.zig").Tokenizer;

const ParseError = @import("error_message.zig").ParseError;
// const raise = @import("error_message.zig").raise;

const perf = @cImport(@cInclude("parse_mnemonic.c"));

const Instruction = struct {
    encoding: u32,
    extension: ?u32 = null,
    reloc: ?[]u8 = null,
};

// ================================================================
//   INSTRUCTION ENCODINGS
// ================================================================

const DataTransfer = packed struct(u32) {
    offset: u10 = 0,
    m: u1 = 0,
    shift: u4 = 0,
    b: u1 = 0,
    h: u1 = 0,
    w: u1 = 0,
    n: u1 = 0,
    p: u1 = 0,
    rm: u4 = 0,
    rd: u4 = 0,
    i: u1 = 0,
    s: u1 = 0,
    _0: u2 = 0b00,
};

const MoveFromPsr = packed struct(u32) {
    _0: u24 = 0x01_8000,
    rd: u4 = 0,
    _1: u4 = 0,
};

const SetClearPsrBits = packed struct(u32) {
    operand: u10 = 0,
    _0: u7 = 0b110_0000,
    s: u1 = 0,
    _1: u10 = 0,
    i: u1 = 0,
    _2: u3 = 0b100,
};

const OP_ADD = 0b000;
const OP_ADC = 0b001;
const OP_SUB = 0b010;
const OP_SBC = 0b011;
const OP_AND = 0b100;
const OP_OR = 0b101;
const OP_XOR = 0b110;
const OP_BTC = 0b111;

const DataProcessing = packed struct(u32) {
    operand2: u10 = 0,
    shift: u5 = 0,
    d: u1 = 0,
    a: u1 = 0,
    op: u3 = 0,
    rm: u4 = 0,
    rd: u4 = 0,
    i: u1 = 0,
    h: u1 = 0,
    _0: u2 = 0b01,
};

const COND_EQ = 0b0000;
const COND_NE = 0b0001;
const COND_CS = 0b0010;
const COND_CC = 0b0011;
const COND_MI = 0b0100;
const COND_PL = 0b0101;
const COND_VS = 0b0110;
const COND_VC = 0b0111;
const COND_HI = 0b1000;
const COND_LS = 0b1001;
const COND_GE = 0b1010;
const COND_LT = 0b1011;
const COND_GT = 0b1100;
const COND_LE = 0b1101;
const COND_AL = 0b1110;

const Branch = packed struct(u32) {
    offset: u24 = 0,
    cond: u4 = 0,
    i: u1 = 0,
    l: u1 = 0,
    _0: 0b10,
};

const MoveImmediate = packed struct(u32) {
    immediate: u24 = 0,
    rd: u4 = 0,
    m: u1 = 0,
    _0: u3 = 0b110,
};

const SoftwareInterrupt = packed struct(u32) {
    comment: u28 = 0,
    _0: u4 = 0b1111,
};

// ================================================================
//   INSTRUCTION PARSING
// ================================================================

pub fn encodeInstruction(line: *Tokenizer, err: *ParseError) !?Instruction {
    const token = line.next() orelse return null;

    // Line is only a comment
    if (token[0] == ';') return null;

    // Resolve mnemonic using perfect hash generated by gperf
    const mnem = perf.parseMnemonic(token.ptr, token.len);
    const inst = switch (mnem) {
        perf.LD => try encodeDataTransfer(line, err, .{}),
        perf.LDB => try encodeDataTransfer(line, err, .{ .b = 1 }),
        perf.LDSB => try encodeDataTransfer(line, err, .{ .b = 1, .m = 1 }),
        perf.LDH => try encodeDataTransfer(line, err, .{ .h = 1 }),
        perf.LDSH => try encodeDataTransfer(line, err, .{ .h = 1, .m = 1 }),
        perf.ST => try encodeDataTransfer(line, err, .{ .s = 1 }),
        perf.STB => try encodeDataTransfer(line, err, .{ .s = 1, .b = 1 }),
        perf.STSB => try encodeDataTransfer(line, err, .{ .s = 1, .b = 1, .m = 1 }),
        perf.STH => try encodeDataTransfer(line, err, .{ .s = 1, .h = 1 }),
        perf.STSH => try encodeDataTransfer(line, err, .{ .s = 1, .h = 1, .m = 1 }),
        perf.SMV => try encodeMoveFromPsr(line, err, .{}),
        perf.SST => try encodeSetClearPsrBits(line, err, .{ .s = 1 }),
        perf.SCL => try encodeSetClearPsrBits(line, err, .{}),
        perf.NOT => try encodeDataProcessing(mnem, line, err, .{ .op = OP_XOR }),
        perf.NOTX => try encodeDataProcessing(mnem, line, err, .{ .op = OP_XOR, .a = 1 }),
        perf.LSL => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD }),
        perf.LSR => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD }),
        perf.ASR => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD }),
        perf.LSLX => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD, .a = 1 }),
        perf.TST => try encodeDataProcessing(mnem, line, err, .{ .op = OP_AND }),
        perf.TEQ => try encodeDataProcessing(mnem, line, err, .{ .op = OP_XOR }),
        perf.CMP => try encodeDataProcessing(mnem, line, err, .{ .op = OP_SUB }),
        perf.CPN => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD }),
        perf.MOV => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD }),
        perf.NOP => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD, .a = 1 }),
        perf.MVI => try encodeMoveImmediate(line, err),
        perf.SWI => try encodeSoftwareInterrupt(line, err),
        perf.MOV32 => try encodeMove32(line, err),
        else => blk: {
            if (mnem >= perf.ADD and mnem <= perf.BTC) {
                break :blk try encodeDataProcessing(mnem, line, err, .{ .op = mnem - perf.ADD });
            } else if (mnem >= perf.ADDX and mnem <= perf.BTCX) {
                break :blk try encodeDataProcessing(mnem, line, err, .{ .op = mnem - perf.ADDX, .a = 1 });
            } else if (mnem >= perf.BEQ and mnem <= perf.B) {
                break :blk try encodeBranch(mnem, line, err, .{
                    .cond = mnem - perf.BEQ,
                });
            } else if (mnem >= perf.BLEQ and mnem <= perf.BL) {
                break :blk try encodeBranch(mnem, line, err, .{ .cond = mnem - perf.BEQ, .l = 1 });
            }
            break :blk error.Unexpected;
        },
    } catch |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected mnemonic\n", .{});
            return error.ParseError;
        },
        else => return e,
    };

    // Catch extraneous tokens after otherwise correct instructions
    if (line.next()) |_| {
        try err.msg("expected EOL\n", .{});
        return error.ParseError;
    }

    return inst;
}

fn encodeDataTransfer(line: *Tokenizer, err: *ParseError, comptime flags: DataTransfer) !Instruction {
    var inst = flags;

    inst.rd = try expectRegister(line, err);

    _ = try expectOperator(",", line, err);
    _ = try expectOperator("[", line, err);

    inst.rm = try expectRegister(line, err);

    switch (try expectOperator("]+-", line, err)) {
        '+' => {},
        '-' => inst.n = 1,
        ']' => {
            if (optionalOperator("+-", line)) |c| switch (c) {
                '+' => inst.p = 1,
                '-' => {
                    inst.n = 1;
                    inst.p = 1;
                },
                else => unreachable,
            } else {
                // Early return if no next token
                _ = line.next() orelse return Instruction{ .encoding = @bitCast(inst) };

                // Extraneous token
                try err.msg("expected '+', '-', or 'EOL'\n", .{});
                return error.ParseError;
            }
        },
        else => unreachable,
    }

    if (expectRegisterOrValue(line, err)) |op| switch (op) {
        .REG => |rn| inst.offset = rn,
        .IMM => |imm| {
            inst.i = 1;

            // Must determine if the immediate value is representable as a
            // shifted 10-bit value
            if (imm <= 0x3FF) {
                // Immediate value fits as is
                inst.offset = @intCast(imm);
            } else {
                // Find representation using shift, if possible
                const leadingZeros = @clz(imm);
                const trailingZeros = @ctz(imm);
                const windowSize = 32 - leadingZeros - trailingZeros;

                // All set bits must fit within in a 10-bit window
                if (windowSize > 10) {
                    try err.msg("offset value not encodable\n", .{});
                    return error.ParseError;
                }

                // If the window is not left-aligned to 2-bits, then it may only be 9-bits wide
                if (leadingZeros % 2 == 1 and windowSize == 10) {
                    try err.msg("offset value not encodable\n", .{});
                    return error.ParseError;
                }

                inst.shift = @intCast(trailingZeros >> 1);
                inst.offset = @intCast(imm >> @intCast(inst.shift << 1));
            }

            // Early return if closing brace already seen
            if (inst.p == 1) return Instruction{ .encoding = @bitCast(inst) };
        },
        else => unreachable,
    } else |e| switch (e) {
        error.ValueNotEncodable => {
            try err.msg("offset value not encodable\n", .{});
            return error.ParseError;
        },
        else => return e,
    }

    // ']' and '!' if no shift value
    if (inst.p == 0) {
        if (optionalOperator("]", line)) |_| {
            if (optionalOperator("!", line)) |_| inst.w = 1;
            return Instruction{ .encoding = @bitCast(inst) };
        }
    }

    // Parse shift for register offsets only
    if (inst.i == 0) {
        // 'lsl'
        var token = line.next() orelse {
            // Early return if closing brace already seen
            if (inst.p == 1) return Instruction{ .encoding = @bitCast(inst) };

            // Missing closing brace
            try err.msg("expected ']' or 'lsl'\n", .{});
            return error.ParseError;
        };
        const mnem = perf.parseMnemonic(token.ptr, token.len);
        switch (mnem) {
            perf.LSL => {},
            else => {
                try err.msg("expected ']', 'lsl', or 'EOL'\n", .{});
                return error.ParseError;
            },
        }

        // Shift value
        token = line.next() catch {
            try err.msg("expected register\n", .{});
            return error.ParseError;
        };
        if (parseInteger(token)) |shift| {
            // Must determine if shift value is multiple of two and less than 32
            if ((shift & ~@as(u32, 0x1E) != 0)) {
                try err.msg("shift value not encodable\n", .{});
                return error.ParseError;
            }
            inst.shift = @intCast(shift >> 1);
        } else |e| switch (e) {
            error.ValueNotEncodable => {
                try err.msg("shift value not encodable\n", .{});
                return error.ParseError;
            },
            error.Unexpected => {
                try err.msg("expected value\n", .{});
                return error.ParseError;
            },
            else => return e,
        }
    }

    // Early return if closing brace already seen
    if (inst.p == 1) return Instruction{ .encoding = @bitCast(inst) };

    _ = try expectOperator("]", line, err);
    _ = optionalOperator("!", line) orelse return Instruction{ .encoding = @bitCast(inst) };

    inst.w = 1;
    return Instruction{ .encoding = @bitCast(inst) };
}

fn encodeMoveFromPsr(line: *Tokenizer, err: *ParseError) !Instruction {
    return Instruction{ .encoding = MoveFromPsr{ .rd = try expectRegister(line, err) } };
}

fn encodeSetClearPsrBits(line: *Tokenizer, err: *ParseError) !Instruction {
    var inst = SetClearPsrBits{};

    inst.rd = try expectRegister(line, err);

    // Rn or offset value
    if (expectRegisterOrValue(line, err)) |op| switch (op) {
        .REG => |rn| inst.operand = rn,
        .IMM => |imm| {
            inst.i = 1;

            // Must determine if the value is representable in 10-bits
            if (imm > 0x3FF) {
                try err.msg("value is not encodable\n", .{});
                return error.ParseError;
            }

            inst.operand = imm;
        },
        else => unreachable,
    } else |e| switch (e) {
        error.ValueNotEncodable => {
            try err.msg("value is not encodable\n", .{});
            return error.ParseError;
        },
        else => return e,
    }

    return Instruction{ .encoding = @bitCast(inst) };
}

fn encodeDataProcessing(mnem: u32, line: *Tokenizer, err: *ParseError, comptime flags: DataProcessing) !Instruction {
    var inst = flags;

    // NOP
    if (mnem == perf.NOP) return Instruction{ .encoding = inst };

    // TST, TEQ, CMP, and CPN all hardcode Rd to R0 (default)
    if (!(mnem >= perf.TST and mnem <= perf.CPN)) {
        inst.rd = try expectRegister(line, err);
        _ = try expectOperator(",", line, err);
    }

    // LSL, LSR, ASR, and LSLX skip all next tokens until Rn or imm
    if (!(mnem >= perf.LSL and mnem <= perf.LSLX)) {
        inst.rm = try expectRegister(line, err);

        // NOT takes immediate value -1 and is done
        if (mnem == perf.NOT or mnem == perf.NOTX) {
            // Immediate values are sign extended to 32-bits
            inst.operand2 = 0x3FF;
            return Instruction{ .encoding = @bitCast(inst) };
        }

        const negated = if (try expectOperator(",", line, err)) |_| true else false;

        if (optionalOperator("-", line)) |_| inst.m = 1;

        // Rn or immediate value
        if (expectRegisterOrValue(line, err)) |op| switch (op) {
            .REG => |rn| {
                if (negated) {
                    try err.msg("registers cannot be negated\n", .{});
                    return error.ParseError;
                }
                inst.operand = rn;
            },
            .IMM => |val| {
                inst.i = 1;

                const imm = if (negated) ~val + 1 else val;

                // Must determine if the value is representable as a 10-bit signed value
                // The value may also be a positive 32-bit value where bits 9-31 are set
                if (imm > 0x1FF and imm & ~@as(u32, 0x1FF) != @as(u32, 0x1FF)) {
                    try err.msg("value is not encodable\n", .{});
                    return error.ParseError;
                }

                inst.operand = @intCast(imm & 0x3FF);
            },
            else => unreachable,
        } else |e| switch (e) {
            error.ValueNotEncodable => {
                try err.msg("value is not encodable\n", .{});
                return error.ParseError;
            },
            else => return e,
        }

        // 'lsl', 'lsr', or 'asr'
        if (line.next()) |token| {
            const shiftMnem = perf.parseMnemonic(token.ptr, token.len);
            switch (shiftMnem) {
                perf.LSL => {},
                perf.LSR => {
                    if (comptime flags.a == 1) {
                        try err.msg("expected 'lsl' or 'EOL'\n", .{});
                        return error.ParseError;
                    }
                    inst.d = 1;
                },
                perf.ASR => {
                    if (comptime flags.a == 1) {
                        try err.msg("expected 'lsl' or 'EOL'\n", .{});
                        return error.ParseError;
                    }
                    inst.d = 1;
                    inst.a = 1;
                },
                else => {
                    if (comptime flags.a == 1) {
                        try err.msg("expected 'lsl' or 'EOL'\n", .{});
                    } else {
                        try err.msg("expected 'lsl', 'lsr', 'asr' or 'EOL'\n", .{});
                    }
                    return error.ParseError;
                },
            }
        } else {
            return Instruction{ .encoding = @bitCast(inst) };
        }
    }

    // Rs or immediate shift
    if (expectRegisterOrValue(line, err)) |op| switch (op) {
        .REG => |rs| inst.shift = rs,
        .IMM => |shift| {
            inst.h = 1;

            // Must determine if the shift is representable as a 5-bit value
            if (shift > 32 or (shift == 32 and inst.d == 0)) {
                try err.msg("shift value is not encodable\n", .{});
                return error.ParseError;
            }

            // 32-bit right shift is encoded as 0, so only update for < 32
            if (shift < 32) inst.shift = @intCast(shift);
        },
        else => unreachable,
    } else |e| switch (e) {
        error.ValueNotEncodable => {
            try err.msg("shift value is not encodable\n", .{});
            return error.ParseError;
        },
        else => return e,
    }

    return Instruction{ .encoding = @bitCast(inst) };
}

fn encodeBranch(line: *Tokenizer, err: *ParseError, comptime flags: Branch) !Instruction {
    var inst = flags;

    // Register or label
    const token = line.next() catch {
        try err.msg("expected register or label\n", .{});
        return error.ParseError;
    };
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| {
            inst.offset = reg;
            return Instruction{ .encoding = inst };
        },
        .LABEL => |label| return Instruction{ .encoding = inst, .reloc = label },
        else => {
            try err.msg("expected register or label\n", .{});
            return error.ParseError;
        },
    } else |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected register or label\n", .{});
            return error.ParseError;
        },
        else => return e,
    }
}

fn encodeMoveImmediate(line: *Tokenizer, err: *ParseError) !Instruction {
    var inst = MoveImmediate{};

    inst.rd = try expectRegister(line, err);

    _ = try expectOperator(",", line, err);

    // Test for optional '-'
    if (optionalOperator("-", line)) |_| inst.m = 1;

    // Parse immediate value
    const token = line.next() catch {
        try err.msg("expected register\n", .{});
        return error.ParseError;
    };
    var imm = parseInteger(token) catch |e| {
        switch (e) {
            error.ValueNotEncodable => try err.msg("value not encodable\n", .{}),
            error.Unexpected => try err.msg("expected immediate value\n", .{}),
        }
        return error.ParseError;
    };

    if (inst.m == 1) {
        //Take two's complement of parsed immediate value
        imm = ~imm + 1;

        // Ensure that value can be encoded by instruction
        if (imm < 0xFF00_0000) {
            try err.msg("value not encodable\n", .{});
            return error.ParseError;
        }

        inst.immediate = @intCast(imm);
        return Instruction{ .encoding = @bitCast(inst) };
    }

    // Ensure that value can be encoded by instruction
    if (imm & 0xFF00_0000 == 0xFF00_0000) {
        // Value is positive, but has 8 highest bits set
        inst.m = 1;
    } else if (imm > 0x00FF_FFFF) {
        try err.msg("value not encodable\n", .{});
        return error.ParseError;
    }

    inst.immediate = @intCast(imm);
    return @bitCast(inst);
}

fn encodeSoftwareInterrupt(line: *Tokenizer, err: *ParseError) !u32 {
    var inst = SoftwareInterrupt{};

    const token = line.next() orelse return @bitCast(inst);
    const comment = parseInteger(token) catch |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected value\n", .{});
            return error.ParseError;
        },
        error.ValueNotEncodable => {
            try err.msg("comment value not encodable\n", .{});
            return error.ParseError;
        },
    };

    if ((comment & ~@as(u32, 0x0FFF_FFFF)) != 0) {
        try err.msg("comment value not encodable\n", .{});
        return error.ParseError;
    }

    inst.comment = comment;
    return inst;
}

fn encodeMove32(line: *Tokenizer, err: *ParseError) !Instruction {
    const rd = try expectRegister(line, err);
    var mviInst = MoveImmediate{
        .rd = rd,
    };
    var orInst = DataProcessing{
        .i = 1,
        .rd = rd,
        .shift = 24,
        .a = 1,
    };

    // Immediate or label
    const token = line.next() catch {
        try err.msg("label or value\n", .{});
        return error.ParseError;
    };
    if (parseOperand(token)) |op| switch (op) {
        .IMM => |imm| {
            mviInst.immediate = @truncate(imm);
            orInst.operand2 = @intCast(imm >> 24);
            return Instruction{ .encoding = mviInst, .extension = orInst };
        },
        .LABEL => |label| return Instruction{ .encoding = mviInst, .extension = orInst, .reloc = label },
        else => {
            try err.msg("expected label or value\n", .{});
            return error.ParseError;
        },
    } else |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected label or value\n", .{});
            return error.ParseError;
        },
        else => return e,
    }
}

// ================================================================
//   PARSING HELPER FUNCTIONS
// ================================================================

inline fn expectRegister(line: *Tokenizer, err: *ParseError) !u4 {
    const token = line.next() catch {
        try err.msg("expected register\n", .{});
        return error.ParseError;
    };
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| return reg,
        else => {
            try err.msg("expected register\n", .{});
            return error.ParseError;
        },
    } else |e| switch (e) {
        else => {
            try err.msg("expected register\n", .{});
            return error.ParseError;
        },
    }
}

inline fn expectRegisterOrValue(line: *Tokenizer, err: *ParseError) !Operand {
    const token = line.next() catch {
        try err.msg("expected register or value\n", .{});
        return error.ParseError;
    };
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| return Operand{ .REG = reg },
        .IMM => |imm| return Operand{ .IMM = imm },
        else => {
            try err.msg("expected register or value\n", .{});
            return error.ParseError;
        },
    } else |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected register or value\n", .{});
            return error.ParseError;
        },
        else => return e,
    }
}

fn operatorListStr(comptime list: []const u8) []const u8 {
    return comptime blk: {
        var result: []const u8 = "";
        if (list.len == 1) break :blk "'" ++ list ++ "'";
        if (list.len == 2) break :blk "'" ++ .{list[0]} ++ "' or '" ++ .{list[1]} ++ "'";
        for (0.., list) |i, c| {
            if (i < list.len - 1) {
                result = result ++ "'" ++ .{c} ++ "', ";
            } else {
                result = result ++ "or '" ++ .{c} ++ "'";
            }
        }
        break :blk result;
    };
}

inline fn expectOperator(
    comptime expect: []const u8,
    line: *Tokenizer,
    err: *ParseError,
) !u8 {
    // Operator list fomatted for error message
    const expectListString = comptime operatorListStr(expect);

    const token = line.next() catch {
        try err.msg("expected register\n", .{});
        return error.ParseError;
    };
    inline for (expect) |c| if (token[0] == c) return c;

    // Token not in operator list
    try err.msg("expected " ++ expectListString ++ "\n", .{});
    return error.ParseError;
}

inline fn optionalOperator(comptime expect: []const u8, line: *Tokenizer) ?u8 {
    const token = line.next() orelse return null;
    inline for (expect) |c| if (token[0] == c) return c;
    line.putBack();
    return null;
}

const OperandTag = enum { REG, IMM, LABEL };
const Operand = union(OperandTag) { REG: u4, IMM: u32, LABEL: []const u8 };

const OperandError = error{ Unexpected, ValueNotEncodable };

fn parseOperand(token: []const u8) !Operand {
    switch (token[0]) {
        'r', 'R' => {
            if (token.len > 3) return error.Unexpected;
            const regNum = try parseDec(token[1..]);
            if (regNum > 0b1111) return error.Unexpected;
            return Operand{ .REG = @intCast(regNum) };
        },
        's' => {
            if (token.len == 2 and token[1] == 'p') return Operand{ .REG = 0b1110 };
            return error.Unexpected;
        },
        'S' => {
            if (token.len == 2 and token[1] == 'P') return Operand{ .REG = 0b1110 };
            return error.Unexpected;
        },
        'l' => {
            if (token.len == 2 and token[1] == 'r') return Operand{ .REG = 0b1111 };
            return error.Unexpected;
        },
        'L' => {
            if (token.len == 2 and token[1] == 'R') return Operand{ .REG = 0b1111 };
            return error.Unexpected;
        },
        '0' => {
            if (token.len < 3) return error.Unexpected;
            if (token[1] == 'x') return Operand{ .IMM = try parseHex(token[2..]) };
            if (token[1] == 'b') return Operand{ .IMM = try parseBin(token[2..]) };
            return error.Unexpected;
        },
        else => {
            if (ascii.isDigit(token[0])) return Operand{ .IMM = try parseDec(token) };
            return Operand{ .LABEL = token };
        },
    }
}

inline fn parseInteger(token: []const u8) !u32 {
    switch (token[0]) {
        '0' => {
            if (token.len < 3) return error.Unexpected;
            if (token[1] == 'x') return try parseHex(token[2..]);
            if (token[1] == 'b') return try parseBin(token[2..]);
            return error.Unexpected;
        },
        else => {
            if (ascii.isDigit(token[0])) return try parseDec(token);
            return error.Unexpected;
        },
    }
}

inline fn parseDec(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val *= 10;
        val += try u8AsDec(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsDec(c: u8) !u4 {
    if (c >= '0' and c <= '9') return @intCast(c - '0');
    return error.Unexpected;
}

inline fn parseHex(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val <<= 4;
        val += try u8AsHex(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsHex(c: u8) !u4 {
    if (c >= '0' and c <= '9') return @intCast(c - '0');
    if (c >= 'A' and c <= 'F') return @intCast(c - 'A' + 10);
    if (c >= 'a' and c <= 'f') return @intCast(c - 'a' + 10);
    return error.Unexpected;
}

inline fn parseBin(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val <<= 1;
        val += try u8AsBin(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsBin(c: u8) !u1 {
    if (c == '0' or c == '1') return @intCast(c - '0');
    return error.Unexpected;
}

// ================================================================
//   TESTS
// ================================================================

/// Unwraps Instruction returns from encodeInstruction into raw u32 encodings
fn ENCODE(line: [:0]const u8) !u32 {
    const ta = std.testing.allocator;
    var err = ParseError.init(ta);
    defer err.text.deinit();
    var tokens = Tokenizer.init(line);
    if (encodeInstruction(&tokens, &err)) |res| {
        const inst = res orelse Instruction{ .encoded = 0, .relocationSymbol = null };
        return inst.encoded;
    } else |e| switch (e) {
        error.ParseError => {
            // std.debug.print("ERROR: {s}\n", .{err.text.items});
            return e;
        },
        else => return e,
    }
}

test "Empty lines" {
    const ta = std.testing.allocator;
    var err = ParseError.init(ta);
    defer err.text.deinit();
    var line = Tokenizer.init("");
    try std.testing.expectEqual(null, try encodeInstruction(&line, &err));
    line = Tokenizer.init("; some comment");
    try std.testing.expectEqual(null, try encodeInstruction(&line, &err));
}

test "Invalid mnemonic" {
    const ta = std.testing.allocator;
    var err = ParseError.init(ta);
    defer err.text.deinit();
    var line = Tokenizer.init("    bad");
    try std.testing.expectError(error.ParseError, encodeInstruction(&line, &err));
}

// --- Data Transfer Instructions

test "DataTransfer -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("    ld"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, ["));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 +"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 -"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + 4"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + r3"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + r3 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + r3 lsl 4"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] +"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] -"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] + r3 lsl"));
}

test "DataTransfer -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("    ld!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 +!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 -!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + 4!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + 4 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + r3!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + r3 lsl!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + r3 lsl 4!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] +!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] -!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] + r3 lsl!"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] + 4 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2]!"));
}

test "DataTransfer -- Unencodable offset value" {
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + 0b1111_1111_111]"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] + 0b1111_1111_111"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + 0b1111_1111_110]"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2] + 0b1111_1111_110"));
}

test "DataTransfer -- Unencodable shift value" {
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + r3 lsl 1]"));
    try std.testing.expectError(error.ParseError, ENCODE("    ld r1, [r2 + r3 lsl 32]"));
}

test "DataTransfer -- Mnemonic variants" {
    try std.testing.expectEqual(0x0120_0000, try ENCODE("    ld    r1, [r2]"));
    try std.testing.expectEqual(0x0120_8000, try ENCODE("    ldb   r1, [r2]"));
    try std.testing.expectEqual(0x0120_8400, try ENCODE("    ldsb  r1, [r2]"));
    try std.testing.expectEqual(0x0121_0000, try ENCODE("    ldh   r1, [r2]"));
    try std.testing.expectEqual(0x0121_0400, try ENCODE("    ldsh  r1, [r2]"));
    try std.testing.expectEqual(0x2120_0000, try ENCODE("    st    r1, [r2]"));
    try std.testing.expectEqual(0x2120_8000, try ENCODE("    stb   r1, [r2]"));
    try std.testing.expectEqual(0x2120_8400, try ENCODE("    stsb  r1, [r2]"));
    try std.testing.expectEqual(0x2121_0000, try ENCODE("    sth   r1, [r2]"));
    try std.testing.expectEqual(0x2121_0400, try ENCODE("    stsh  r1, [r2]"));
}

test "DataTransfer -- No writeback register offset" {
    try std.testing.expectEqual(0x0120_0003, try ENCODE("    ld    r1, [r2 + r3]"));
    try std.testing.expectEqual(0x0124_0003, try ENCODE("    ld    r1, [r2 - r3]"));
    try std.testing.expectEqual(0x0120_1003, try ENCODE("    ld    r1, [r2 + r3 lsl 4]"));
    try std.testing.expectEqual(0x0124_1003, try ENCODE("    ld    r1, [r2 - r3 lsl 4]"));
}

test "DataTransfer -- No writeback immediate" {
    try std.testing.expectEqual(0x1120_02AA, try ENCODE("    ld    r1, [r2 + 0x02AA]"));
    try std.testing.expectEqual(0x1124_02AA, try ENCODE("    ld    r1, [r2 - 0x02AA]"));
}

test "Datatransfer -- Pre-increment register offset" {
    try std.testing.expectEqual(0x0122_0003, try ENCODE("    ld    r1, [r2 + r3]!"));
    try std.testing.expectEqual(0x0126_0003, try ENCODE("    ld    r1, [r2 - r3]!"));
    try std.testing.expectEqual(0x0122_1003, try ENCODE("    ld    r1, [r2 + r3 lsl 4]!"));
    try std.testing.expectEqual(0x0126_1003, try ENCODE("    ld    r1, [r2 - r3 lsl 4]!"));
}

test "Datatransfer -- Pre-increment writeback immediate" {
    try std.testing.expectEqual(0x1122_02AA, try ENCODE("    ld    r1, [r2 + 0x02AA]!"));
    try std.testing.expectEqual(0x1126_02AA, try ENCODE("    ld    r1, [r2 - 0x02AA]!"));
}

test "Datatransfer -- Post-increment register offset" {
    try std.testing.expectEqual(0x0128_0003, try ENCODE("    ld    r1, [r2] + r3"));
    try std.testing.expectEqual(0x012C_0003, try ENCODE("    ld    r1, [r2] - r3"));
    try std.testing.expectEqual(0x0128_1003, try ENCODE("    ld    r1, [r2] + r3 lsl 4"));
    try std.testing.expectEqual(0x012C_1003, try ENCODE("    ld    r1, [r2] - r3 lsl 4"));
}

test "Datatransfer -- Post-increment writeback immediate" {
    try std.testing.expectEqual(0x1128_02AA, try ENCODE("    ld    r1, [r2] + 0x02AA"));
    try std.testing.expectEqual(0x112C_02AA, try ENCODE("    ld    r1, [r2] - 0x02AA"));
}

test "Datatransfer -- Implicitly shifted immediate" {
    try std.testing.expectEqual(0x1120_12AA, try ENCODE("    ld    r1, [r2 + 0x2AA0]"));
    try std.testing.expectEqual(0x1120_2851, try ENCODE("    ld    r1, [r2 + 0x14400]"));
    try std.testing.expectEqual(0x1120_1992, try ENCODE("    ld    r1, [r2 + 0x6480]"));
    try std.testing.expectEqual(0x1120_2341, try ENCODE("    ld    r1, [r2 + 0x34100]"));
}

// --- Move From PSR Instruction

test "MoveFromPsr -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("    smv"));
}

test "MoveFromPsr -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("    smv!"));
    try std.testing.expectError(error.ParseError, ENCODE("    smv r1!"));
}

test "MoveFromPsr --"

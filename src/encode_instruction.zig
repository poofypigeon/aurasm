const std = @import("std");
const ascii = std.ascii;

const Tokenizer = @import("tokenizer.zig").Tokenizer;

const ParseError = @import("error_message.zig").ParseError;
const displayTokenInline = @import("error_message.zig").displayTokenInLine;
// const raise = @import("error_message.zig").raise;

const perf = @cImport(@cInclude("parse_mnemonic.c"));

const Instruction = struct {
    encoding: u32,
    extension: ?u32 = null,
    reloc: ?[]const u8 = null,
};

// ================================================================
//   INSTRUCTION ENCODINGS
// ================================================================

const DataTransfer = packed struct(u32) {
    offset: u10 = 0,
    m: u1 = 0,
    shift: u4 = 0,
    b: u1 = 0,
    h: u1 = 0,
    w: u1 = 0,
    n: u1 = 0,
    p: u1 = 0,
    rm: u4 = 0,
    rd: u4 = 0,
    i: u1 = 0,
    s: u1 = 0,
    _0: u2 = 0b00,
};

const MoveFromPsr = packed struct(u32) {
    _0: u24 = 0x01_8000,
    rd: u4 = 0,
    _1: u4 = 0,
};

const SetClearPsrBits = packed struct(u32) {
    operand: u10 = 0,
    _0: u7 = 0b110_0000,
    s: u1 = 0,
    _1: u10 = 0,
    i: u1 = 0,
    _2: u3 = 0b001,
};

const OP_ADD = 0b000;
const OP_ADC = 0b001;
const OP_SUB = 0b010;
const OP_SBC = 0b011;
const OP_AND = 0b100;
const OP_OR = 0b101;
const OP_XOR = 0b110;
const OP_BTC = 0b111;

const DataProcessing = packed struct(u32) {
    operand2: u10 = 0,
    shift: u5 = 0,
    d: u1 = 0,
    a: u1 = 0,
    op: u3 = 0,
    rm: u4 = 0,
    rd: u4 = 0,
    i: u1 = 0,
    h: u1 = 0,
    _0: u2 = 0b01,
};

const COND_EQ = 0b0000;
const COND_NE = 0b0001;
const COND_CS = 0b0010;
const COND_CC = 0b0011;
const COND_MI = 0b0100;
const COND_PL = 0b0101;
const COND_VS = 0b0110;
const COND_VC = 0b0111;
const COND_HI = 0b1000;
const COND_LS = 0b1001;
const COND_GE = 0b1010;
const COND_LT = 0b1011;
const COND_GT = 0b1100;
const COND_LE = 0b1101;
const COND_AL = 0b1110;

const Branch = packed struct(u32) {
    offset: u24 = 0,
    cond: u4 = 0,
    i: u1 = 0,
    l: u1 = 0,
    _0: u2 = 0b10,
};

const MoveImmediate = packed struct(u32) {
    immediate: u24 = 0,
    rd: u4 = 0,
    m: u1 = 0,
    _0: u3 = 0b110,
};

const SoftwareInterrupt = packed struct(u32) {
    comment: u28 = 0,
    _0: u4 = 0b1111,
};

// ================================================================
//   INSTRUCTION PARSING
// ================================================================

pub fn encodeInstruction(line: *Tokenizer, err: *ParseError) !?Instruction {
    const token = line.next() orelse return null;

    // Line is only a comment
    if (token[0] == ';') return null;

    // Resolve mnemonic using perfect hash generated by gperf
    const mnem = perf.parseMnemonic(token.ptr, token.len);
    const inst = switch (mnem) {
        perf.LD => try encodeDataTransfer(line, err, .{}),
        perf.LDB => try encodeDataTransfer(line, err, .{ .b = 1 }),
        perf.LDSB => try encodeDataTransfer(line, err, .{ .b = 1, .m = 1 }),
        perf.LDH => try encodeDataTransfer(line, err, .{ .h = 1 }),
        perf.LDSH => try encodeDataTransfer(line, err, .{ .h = 1, .m = 1 }),
        perf.ST => try encodeDataTransfer(line, err, .{ .s = 1 }),
        perf.STB => try encodeDataTransfer(line, err, .{ .s = 1, .b = 1 }),
        perf.STSB => try encodeDataTransfer(line, err, .{ .s = 1, .b = 1, .m = 1 }),
        perf.STH => try encodeDataTransfer(line, err, .{ .s = 1, .h = 1 }),
        perf.STSH => try encodeDataTransfer(line, err, .{ .s = 1, .h = 1, .m = 1 }),
        perf.SMV => try encodeMoveFromPsr(line, err),
        perf.SST => try encodeSetClearPsrBits(line, err, .{ .s = 1 }),
        perf.SCL => try encodeSetClearPsrBits(line, err, .{}),
        perf.NOT => try encodeDataProcessing(mnem, line, err, .{ .op = OP_XOR, .i = 1, .operand2 = 0x3FF }),
        perf.NOTX => try encodeDataProcessing(mnem, line, err, .{ .op = OP_XOR, .i = 1, .operand2 = 0x3FF, .a = 1 }),
        perf.LSL => try encodeDataProcessing(mnem, line, err, .{ .op = OP_OR }),
        perf.LSR => try encodeDataProcessing(mnem, line, err, .{ .op = OP_OR, .d = 1 }),
        perf.ASR => try encodeDataProcessing(mnem, line, err, .{ .op = OP_OR, .a = 1, .d = 1 }),
        perf.LSLX => try encodeDataProcessing(mnem, line, err, .{ .op = OP_OR, .a = 1 }),
        perf.TST => try encodeDataProcessing(mnem, line, err, .{ .op = OP_AND }),
        perf.TEQ => try encodeDataProcessing(mnem, line, err, .{ .op = OP_XOR }),
        perf.CMP => try encodeDataProcessing(mnem, line, err, .{ .op = OP_SUB }),
        perf.CPN => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD }),
        perf.MOV => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD, .a = 1 }),
        perf.NOP => try encodeDataProcessing(mnem, line, err, .{ .op = OP_ADD, .a = 1 }),
        perf.MVI => try encodeMoveImmediate(line, err),
        perf.SWI => try encodeSoftwareInterrupt(line, err),
        perf.MOV32 => try encodeMove32(line, err),
        else => blk: {
            if (mnem >= perf.ADD and mnem <= perf.BTC) {
                break :blk try encodeDataProcessing(mnem, line, err, .{ .op = @intCast(mnem - perf.ADD) });
            } else if (mnem >= perf.ADDX and mnem <= perf.BTCX) {
                break :blk try encodeDataProcessing(mnem, line, err, .{ .op = @intCast(mnem - perf.ADDX), .a = 1 });
            } else if (mnem >= perf.BEQ and mnem <= perf.B) {
                break :blk try encodeBranch(line, err, .{ .cond = @intCast(mnem - perf.BEQ) });
            } else if (mnem >= perf.BLEQ and mnem <= perf.BL) {
                break :blk try encodeBranch(line, err, .{ .cond = @intCast(mnem - perf.BLEQ), .l = 1 });
            }
            break :blk error.Unexpected;
        },
    } catch |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected mnemonic\n", .{});
            return error.ParseError;
        },
        else => return e,
    };

    // Catch extraneous tokens after otherwise correct instructions
    if (line.next()) |_| {
        try err.msg("expected EOL\n", .{});
        return error.ParseError;
    }

    return inst;
}

fn encodeDataTransfer(line: *Tokenizer, err: *ParseError, comptime flags: DataTransfer) !Instruction {
    var inst = flags;

    inst.rd = try expectRegister(line, err);

    _ = try expectOperator(",", line, err);
    _ = try expectOperator("[", line, err);

    inst.rm = try expectRegister(line, err);

    switch (try expectOperator("]+-", line, err)) {
        '+' => {},
        '-' => inst.n = 1,
        ']' => {
            if (optionalOperator("+-", line)) |c| switch (c) {
                '+' => inst.p = 1,
                '-' => {
                    inst.n = 1;
                    inst.p = 1;
                },
                else => unreachable,
            } else {
                // Early return if no next token
                _ = line.next() orelse return Instruction{ .encoding = @bitCast(inst) };

                // Extraneous token
                try err.msg("expected '+', '-', or 'EOL'\n", .{});
                return error.ParseError;
            }
        },
        else => unreachable,
    }

    if (expectRegisterOrValue(line, err)) |op| switch (op) {
        .REG => |rn| inst.offset = rn,
        .IMM => |imm| {
            inst.i = 1;

            // Must determine if the immediate value is representable as a
            // shifted 10-bit value
            if (imm <= 0x3FF) {
                // Immediate value fits as is
                inst.offset = @intCast(imm);
            } else {
                // Find representation using shift, if possible
                const leadingZeros = @clz(imm);
                const trailingZeros = @ctz(imm);
                const windowSize = 32 - leadingZeros - trailingZeros;

                // All set bits must fit within in a 10-bit window
                if (windowSize > 10) {
                    try err.msg("offset value not encodable\n", .{});
                    return error.ParseError;
                }

                // If the window is not left-aligned to 2-bits, then it may only be 9-bits wide
                if (leadingZeros % 2 == 1 and windowSize == 10) {
                    try err.msg("offset value not encodable\n", .{});
                    return error.ParseError;
                }

                inst.shift = @intCast(trailingZeros >> 1);
                inst.offset = @intCast(imm >> @intCast(inst.shift << 1));
            }

            // Early return if closing brace already seen
            if (inst.p == 1) return Instruction{ .encoding = @bitCast(inst) };
        },
        else => unreachable,
    } else |e| switch (e) {
        error.ValueNotEncodable => {
            try err.msg("offset value not encodable\n", .{});
            return error.ParseError;
        },
        else => return e,
    }

    // ']' and '!' if no shift value
    if (inst.p == 0) {
        if (optionalOperator("]", line)) |_| {
            if (optionalOperator("!", line)) |_| inst.w = 1;
            return Instruction{ .encoding = @bitCast(inst) };
        }
    }

    // Parse shift for register offsets only
    if (inst.i == 0) {
        // 'lsl'
        var token = line.next() orelse {
            // Early return if closing brace already seen
            if (inst.p == 1) return Instruction{ .encoding = @bitCast(inst) };

            // Missing closing brace
            try err.msg("expected ']' or 'lsl'\n", .{});
            return error.ParseError;
        };
        const mnem = perf.parseMnemonic(token.ptr, token.len);
        switch (mnem) {
            perf.LSL => {},
            else => {
                try err.msg("expected ']', 'lsl', or 'EOL'\n", .{});
                return error.ParseError;
            },
        }

        // Shift value
        token = line.next() orelse {
            try err.msg("expected register\n", .{});
            return error.ParseError;
        };
        if (parseInteger(token)) |shift| {
            // Must determine if shift value is multiple of two and less than 32
            if ((shift & ~@as(u32, 0x1E) != 0)) {
                try err.msg("shift value not encodable\n", .{});
                return error.ParseError;
            }
            inst.shift = @intCast(shift >> 1);
        } else |e| switch (e) {
            error.ValueNotEncodable => {
                try err.msg("shift value not encodable\n", .{});
                return error.ParseError;
            },
            error.Unexpected => {
                try err.msg("expected value\n", .{});
                return error.ParseError;
            },
            else => return e,
        }
    }

    // Early return if closing brace already seen
    if (inst.p == 1) return Instruction{ .encoding = @bitCast(inst) };

    _ = try expectOperator("]", line, err);
    _ = optionalOperator("!", line) orelse return Instruction{ .encoding = @bitCast(inst) };

    inst.w = 1;
    return Instruction{ .encoding = @bitCast(inst) };
}

fn encodeMoveFromPsr(line: *Tokenizer, err: *ParseError) !Instruction {
    return Instruction{ .encoding = @bitCast(MoveFromPsr{ .rd = try expectRegister(line, err) }) };
}

fn encodeSetClearPsrBits(line: *Tokenizer, err: *ParseError, flags: SetClearPsrBits) !Instruction {
    var inst = flags;

    // Rn or offset value
    if (expectRegisterOrValue(line, err)) |op| switch (op) {
        .REG => |rn| inst.operand = rn,
        .IMM => |imm| {
            inst.i = 1;

            // Must determine if the value is representable in 10-bits
            if (imm > 0x3FF) {
                try err.msg("value is not encodable\n", .{});
                return error.ParseError;
            }

            inst.operand = @intCast(imm);
        },
        else => unreachable,
    } else |e| switch (e) {
        error.ValueNotEncodable => {
            try err.msg("value is not encodable\n", .{});
            return error.ParseError;
        },
        else => return e,
    }

    return Instruction{ .encoding = @bitCast(inst) };
}

fn encodeDataProcessing(mnem: u32, line: *Tokenizer, err: *ParseError, flags: DataProcessing) !Instruction {
    var inst = flags;

    // NOP
    if (mnem == perf.NOP) return Instruction{ .encoding = @bitCast(inst) };

    // TST, TEQ, CMP, and CPN all hardcode Rd to R0 (default)
    if (!(mnem >= perf.TST and mnem <= perf.CPN)) {
        inst.rd = try expectRegister(line, err);
        _ = try expectOperator(",", line, err);
    }

    // LSL, LSR, ASR, and LSLX do not take an Rm value, only Rn
    if (mnem >= perf.LSL and mnem <= perf.LSLX) {
        inst.operand2 = try expectRegister(line, err);
        _ = try expectOperator(",", line, err);
    } else {
        inst.rm = try expectRegister(line, err);

        if (mnem == perf.MOV or mnem == perf.NOT or mnem == perf.NOTX) {
            return Instruction{ .encoding = @bitCast(inst) };
        }

        _ = try expectOperator(",", line, err);

        const negated = if (optionalOperator("-", line)) |_| true else false;

        // Rn or immediate value
        if (expectRegisterOrValue(line, err)) |op| switch (op) {
            .REG => |rn| {
                if (negated) {
                    try err.msg("registers cannot be negated\n", .{});
                    return error.ParseError;
                }
                inst.operand2 = rn;
            },
            .IMM => |val| {
                inst.i = 1;

                const imm = if (negated) ~val + 1 else val;

                // Must determine if the value is representable as a 10-bit signed value
                // The value may also be a positive 32-bit value where bits 9-31 are set
                if (imm > 0x1FF and imm & ~@as(u32, 0x1FF) != @as(u32, 0x1FF)) {
                    try err.msg("value is not encodable\n", .{});
                    return error.ParseError;
                }

                inst.operand2 = @intCast(imm & 0x3FF);
            },
            else => unreachable,
        } else |e| switch (e) {
            error.ValueNotEncodable => {
                try err.msg("value is not encodable\n", .{});
                return error.ParseError;
            },
            else => return e,
        }

        // 'lsl', 'lsr', or 'asr'
        if (line.next()) |token| {
            const shiftMnem = perf.parseMnemonic(token.ptr, token.len);
            switch (shiftMnem) {
                perf.LSL => {},
                perf.LSR => {
                    if (flags.a == 1) {
                        try err.msg("right shifts are not encodable for 'x' instruction variants\n", .{});
                        return error.ParseError;
                    }
                    inst.d = 1;
                },
                perf.ASR => {
                    if (flags.a == 1) {
                        try err.msg("right shifts are not encodable for 'x' instruction variants\n", .{});
                        return error.ParseError;
                    }
                    inst.d = 1;
                    inst.a = 1;
                },
                else => {
                    if (flags.a == 1) {
                        try err.msg("expected 'lsl' or 'EOL'\n", .{});
                    } else {
                        try err.msg("expected 'lsl', 'lsr', 'asr' or 'EOL'\n", .{});
                    }
                    return error.ParseError;
                },
            }
        } else {
            return Instruction{ .encoding = @bitCast(inst) };
        }
    }

    // Rs or immediate shift
    if (expectRegisterOrValue(line, err)) |op| switch (op) {
        .REG => |rs| inst.shift = rs,
        .IMM => |shift| {
            inst.h = 1;

            // Must determine if the shift is representable as a 5-bit value
            if (shift > 32 or (shift == 32 and inst.d == 0)) {
                try err.msg("shift value is not encodable\n", .{});
                return error.ParseError;
            }

            // 32-bit right shift is encoded as 0, so only update for < 32
            if (shift < 32) inst.shift = @intCast(shift);
        },
        else => unreachable,
    } else |e| switch (e) {
        error.ValueNotEncodable => {
            try err.msg("shift value is not encodable\n", .{});
            return error.ParseError;
        },
        else => return e,
    }

    return Instruction{ .encoding = @bitCast(inst) };
}

fn encodeBranch(line: *Tokenizer, err: *ParseError, flags: Branch) !Instruction {
    var inst = flags;

    // Register or label
    const token = line.next() orelse {
        try err.msg("expected register or label\n", .{});
        return error.ParseError;
    };
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| {
            inst.offset = reg;
            return Instruction{ .encoding = @bitCast(inst) };
        },
        .LABEL => |label| return Instruction{ .encoding = @bitCast(inst), .reloc = label },
        else => {
            try err.msg("expected register or label\n", .{});
            return error.ParseError;
        },
    } else |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected register or label\n", .{});
            return error.ParseError;
        },
        else => return e,
    }
}

fn encodeMoveImmediate(line: *Tokenizer, err: *ParseError) !Instruction {
    var inst = MoveImmediate{};

    inst.rd = try expectRegister(line, err);

    _ = try expectOperator(",", line, err);

    // Test for optional '-'
    if (optionalOperator("-", line)) |_| inst.m = 1;

    // Parse immediate value
    const token = line.next() orelse {
        try err.msg("expected register\n", .{});
        return error.ParseError;
    };
    var imm = parseInteger(token) catch |e| {
        switch (e) {
            error.ValueNotEncodable => try err.msg("value not encodable\n", .{}),
            error.Unexpected => try err.msg("expected immediate value\n", .{}),
        }
        return error.ParseError;
    };

    if (inst.m == 1) {
        //Take two's complement of parsed immediate value
        imm = ~imm + 1;

        // Ensure that value can be encoded by instruction
        if (imm < 0xFF00_0000) {
            try err.msg("value not encodable\n", .{});
            return error.ParseError;
        }

        inst.immediate = @truncate(imm);
        return Instruction{ .encoding = @bitCast(inst) };
    }

    // Ensure that value can be encoded by instruction
    if (imm & 0xFF00_0000 == 0xFF00_0000) {
        // Value is positive, but has 8 highest bits set
        inst.m = 1;
    } else if (imm > 0x00FF_FFFF) {
        try err.msg("value not encodable\n", .{});
        return error.ParseError;
    }

    inst.immediate = @intCast(imm);
    return Instruction{ .encoding = @bitCast(inst) };
}

fn encodeSoftwareInterrupt(line: *Tokenizer, err: *ParseError) !Instruction {
    var inst = SoftwareInterrupt{};

    const token = line.next() orelse return Instruction{ .encoding = @bitCast(inst) };
    const comment = parseInteger(token) catch |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected value\n", .{});
            return error.ParseError;
        },
        error.ValueNotEncodable => {
            try err.msg("comment value not encodable\n", .{});
            return error.ParseError;
        },
    };

    if ((comment & ~@as(u32, 0x0FFF_FFFF)) != 0) {
        try err.msg("comment value not encodable\n", .{});
        return error.ParseError;
    }

    inst.comment = @intCast(comment);
    return Instruction{ .encoding = @bitCast(inst) };
}

fn encodeMove32(line: *Tokenizer, err: *ParseError) !Instruction {
    const rd = try expectRegister(line, err);
    var mviInst = MoveImmediate{
        .rd = rd,
    };
    var addInst = DataProcessing{
        .h = 1,
        .i = 1,
        .rd = rd,
        .shift = 24,
        .a = 1,
    };

    _ = try expectOperator(",", line, err);

    // Immediate or label
    const token = line.next() orelse {
        try err.msg("label or value\n", .{});
        return error.ParseError;
    };
    if (parseOperand(token)) |op| switch (op) {
        .IMM => |imm| {
            mviInst.immediate = @truncate(imm);
            addInst.operand2 = @intCast(imm >> 24);
            return Instruction{
                .encoding = @bitCast(mviInst),
                .extension = @bitCast(addInst),
            };
        },
        .LABEL => |label| return Instruction{
            .encoding = @bitCast(mviInst),
            .extension = @bitCast(addInst),
            .reloc = label,
        },
        else => {
            try err.msg("expected label or value\n", .{});
            return error.ParseError;
        },
    } else |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected label or value\n", .{});
            return error.ParseError;
        },
        else => return e,
    }
}

// ================================================================
//   PARSING HELPER FUNCTIONS
// ================================================================

inline fn expectRegister(line: *Tokenizer, err: *ParseError) !u4 {
    const token = line.next() orelse {
        try err.msg("expected register\n", .{});
        return error.ParseError;
    };
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| return reg,
        else => {
            try err.msg("expected register\n", .{});
            return error.ParseError;
        },
    } else |e| switch (e) {
        else => {
            try err.msg("expected register\n", .{});
            return error.ParseError;
        },
    }
}

inline fn expectRegisterOrValue(line: *Tokenizer, err: *ParseError) !Operand {
    const token = line.next() orelse {
        try err.msg("expected register or value\n", .{});
        return error.ParseError;
    };
    if (parseOperand(token)) |op| switch (op) {
        .REG => |reg| return Operand{ .REG = reg },
        .IMM => |imm| return Operand{ .IMM = imm },
        else => {
            try err.msg("expected register or value\n", .{});
            return error.ParseError;
        },
    } else |e| switch (e) {
        error.Unexpected => {
            try err.msg("expected register or value\n", .{});
            return error.ParseError;
        },
        else => return e,
    }
}

fn operatorListStr(comptime list: []const u8) []const u8 {
    return comptime blk: {
        var result: []const u8 = "";
        if (list.len == 1) break :blk "'" ++ list ++ "'";
        if (list.len == 2) break :blk "'" ++ .{list[0]} ++ "' or '" ++ .{list[1]} ++ "'";
        for (0.., list) |i, c| {
            if (i < list.len - 1) {
                result = result ++ "'" ++ .{c} ++ "', ";
            } else {
                result = result ++ "or '" ++ .{c} ++ "'";
            }
        }
        break :blk result;
    };
}

inline fn expectOperator(
    comptime expect: []const u8,
    line: *Tokenizer,
    err: *ParseError,
) !u8 {
    // Operator list fomatted for error message
    const expectListString = comptime operatorListStr(expect);

    const token = line.next() orelse {
        try err.msg("expected {s}\n", .{expectListString});
        return error.ParseError;
    };
    inline for (expect) |c| if (token[0] == c) return c;

    // Token not in operator list
    try err.msg("expected " ++ expectListString ++ "\n", .{});
    return error.ParseError;
}

inline fn optionalOperator(comptime expect: []const u8, line: *Tokenizer) ?u8 {
    const token = line.next() orelse return null;
    inline for (expect) |c| if (token[0] == c) return c;
    line.putBack();
    return null;
}

const OperandTag = enum { REG, IMM, LABEL };
const Operand = union(OperandTag) { REG: u4, IMM: u32, LABEL: []const u8 };

const OperandError = error{ Unexpected, ValueNotEncodable };

fn parseOperand(token: []const u8) !Operand {
    switch (token[0]) {
        'r', 'R' => {
            if (token.len > 3) return error.Unexpected;
            const regNum = try parseDec(token[1..]);
            if (regNum > 0b1111) return error.Unexpected;
            return Operand{ .REG = @intCast(regNum) };
        },
        's' => if (token.len == 2 and token[1] == 'p') return Operand{ .REG = 0b1110 },
        'S' => if (token.len == 2 and token[1] == 'P') return Operand{ .REG = 0b1110 },
        'l' => if (token.len == 2 and token[1] == 'r') return Operand{ .REG = 0b1111 },
        'L' => if (token.len == 2 and token[1] == 'R') return Operand{ .REG = 0b1111 },
        '0' => {
            if (token.len < 3) return error.Unexpected;
            if (token[1] == 'x') return Operand{ .IMM = try parseHex(token[2..]) };
            if (token[1] == 'b') return Operand{ .IMM = try parseBin(token[2..]) };
            return error.Unexpected;
        },
        else => {
            if (ascii.isDigit(token[0])) return Operand{ .IMM = try parseDec(token) };
            if (!(ascii.isAlphabetic(token[0]) or token[0] == '_')) return error.Unexpected;
        },
    }
    return Operand{ .LABEL = token };
}

inline fn parseInteger(token: []const u8) !u32 {
    switch (token[0]) {
        '0' => {
            if (token.len < 3) return error.Unexpected;
            if (token[1] == 'x') return try parseHex(token[2..]);
            if (token[1] == 'b') return try parseBin(token[2..]);
            return error.Unexpected;
        },
        else => {
            if (ascii.isDigit(token[0])) return try parseDec(token);
            return error.Unexpected;
        },
    }
}

inline fn parseDec(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val *= 10;
        val += try u8AsDec(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsDec(c: u8) !u4 {
    if (c >= '0' and c <= '9') return @intCast(c - '0');
    return error.Unexpected;
}

inline fn parseHex(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val <<= 4;
        val += try u8AsHex(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsHex(c: u8) !u4 {
    if (c >= '0' and c <= '9') return @intCast(c - '0');
    if (c >= 'A' and c <= 'F') return @intCast(c - 'A' + 10);
    if (c >= 'a' and c <= 'f') return @intCast(c - 'a' + 10);
    return error.Unexpected;
}

inline fn parseBin(token: []const u8) !u32 {
    var val: u64 = 0;
    for (token) |c| {
        if (c == '_') continue;
        val <<= 1;
        val += try u8AsBin(c);
        if (val & (1 << 32) != 0) return error.ValueNotEncodable;
    }
    return @intCast(val);
}

inline fn u8AsBin(c: u8) !u1 {
    if (c == '0' or c == '1') return @intCast(c - '0');
    return error.Unexpected;
}

// ================================================================
//   TESTS
// ================================================================

/// Unwraps Instruction returns from encodeInstruction
fn INST(line: [:0]const u8) !Instruction {
    const ta = std.testing.allocator;
    var err = ParseError.init(ta);
    defer err.text.deinit();
    var tokens = Tokenizer.init(line);
    if (encodeInstruction(&tokens, &err)) |res| {
        return res orelse Instruction{ .encoding = 0, .reloc = null };
    } else |e| switch (e) {
        error.ParseError => {
            std.debug.print("ERROR: {s}", .{err.text.items});
            try displayTokenInline(tokens);

            return e;
        },
        else => return e,
    }
}

/// Unwraps Instruction returns from encodeInstruction into raw u32 encodings
fn ENCODE(line: [:0]const u8) !u32 {
    const ta = std.testing.allocator;
    var err = ParseError.init(ta);
    defer err.text.deinit();
    var tokens = Tokenizer.init(line);
    if (encodeInstruction(&tokens, &err)) |res| {
        const inst = res orelse Instruction{ .encoding = 0, .reloc = null };
        return inst.encoding;
    } else |e| switch (e) {
        error.ParseError => {
            std.debug.print("ERROR: {s}", .{err.text.items});
            try displayTokenInline(tokens);

            return e;
        },
        else => return e,
    }
}

test "Empty lines" {
    const ta = std.testing.allocator;
    var err = ParseError.init(ta);
    defer err.text.deinit();
    var line = Tokenizer.init("");
    try std.testing.expectEqual(null, try encodeInstruction(&line, &err));
    line = Tokenizer.init("; some comment");
    try std.testing.expectEqual(null, try encodeInstruction(&line, &err));
}

test "Invalid mnemonic" {
    const ta = std.testing.allocator;
    var err = ParseError.init(ta);
    defer err.text.deinit();
    var line = Tokenizer.init("    bad");
    try std.testing.expectError(error.ParseError, encodeInstruction(&line, &err));
}

// --- Data Transfer Instructions

test "DataTransfer -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("ld"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, ["));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 +"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 -"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 4"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl 4"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] +"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] -"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + r3 lsl"));
}

test "DataTransfer -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("ld!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 +!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 -!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 4!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 4 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl 4!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] +!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] -!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + r3 lsl!"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + 4 lsl"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2]!"));
}

test "DataTransfer -- Unencodable offset value" {
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 0b1111_1111_111]"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + 0b1111_1111_111"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + 0b1111_1111_110]"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2] + 0b1111_1111_110"));
}

test "DataTransfer -- Unencodable shift value" {
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl 1]"));
    try std.testing.expectError(error.ParseError, ENCODE("ld r1, [r2 + r3 lsl 32]"));
}

test "DataTransfer -- Mnemonic variants" {
    try std.testing.expectEqual(0x0120_0000, try ENCODE("ld    r1, [r2]"));
    try std.testing.expectEqual(0x0120_8000, try ENCODE("ldb   r1, [r2]"));
    try std.testing.expectEqual(0x0120_8400, try ENCODE("ldsb  r1, [r2]"));
    try std.testing.expectEqual(0x0121_0000, try ENCODE("ldh   r1, [r2]"));
    try std.testing.expectEqual(0x0121_0400, try ENCODE("ldsh  r1, [r2]"));
    try std.testing.expectEqual(0x2120_0000, try ENCODE("st    r1, [r2]"));
    try std.testing.expectEqual(0x2120_8000, try ENCODE("stb   r1, [r2]"));
    try std.testing.expectEqual(0x2120_8400, try ENCODE("stsb  r1, [r2]"));
    try std.testing.expectEqual(0x2121_0000, try ENCODE("sth   r1, [r2]"));
    try std.testing.expectEqual(0x2121_0400, try ENCODE("stsh  r1, [r2]"));
}

test "DataTransfer -- No writeback register offset" {
    try std.testing.expectEqual(0x0120_0003, try ENCODE("ld r1, [r2 + r3]"));
    try std.testing.expectEqual(0x0124_0003, try ENCODE("ld r1, [r2 - r3]"));
    try std.testing.expectEqual(0x0120_1003, try ENCODE("ld r1, [r2 + r3 lsl 4]"));
    try std.testing.expectEqual(0x0124_1003, try ENCODE("ld r1, [r2 - r3 lsl 4]"));
}

test "DataTransfer -- No writeback immediate" {
    try std.testing.expectEqual(0x1120_02AA, try ENCODE("ld r1, [r2 + 0x02AA]"));
    try std.testing.expectEqual(0x1124_02AA, try ENCODE("ld r1, [r2 - 0x02AA]"));
}

test "Datatransfer -- Pre-increment register offset" {
    try std.testing.expectEqual(0x0122_0003, try ENCODE("ld r1, [r2 + r3]!"));
    try std.testing.expectEqual(0x0126_0003, try ENCODE("ld r1, [r2 - r3]!"));
    try std.testing.expectEqual(0x0122_1003, try ENCODE("ld r1, [r2 + r3 lsl 4]!"));
    try std.testing.expectEqual(0x0126_1003, try ENCODE("ld r1, [r2 - r3 lsl 4]!"));
}

test "Datatransfer -- Pre-increment writeback immediate" {
    try std.testing.expectEqual(0x1122_02AA, try ENCODE("ld r1, [r2 + 0x02AA]!"));
    try std.testing.expectEqual(0x1126_02AA, try ENCODE("ld r1, [r2 - 0x02AA]!"));
}

test "Datatransfer -- Post-increment register offset" {
    try std.testing.expectEqual(0x0128_0003, try ENCODE("ld r1, [r2] + r3"));
    try std.testing.expectEqual(0x012C_0003, try ENCODE("ld r1, [r2] - r3"));
    try std.testing.expectEqual(0x0128_1003, try ENCODE("ld r1, [r2] + r3 lsl 4"));
    try std.testing.expectEqual(0x012C_1003, try ENCODE("ld r1, [r2] - r3 lsl 4"));
}

test "Datatransfer -- Post-increment writeback immediate" {
    try std.testing.expectEqual(0x1128_02AA, try ENCODE("ld r1, [r2] + 0x02AA"));
    try std.testing.expectEqual(0x112C_02AA, try ENCODE("ld r1, [r2] - 0x02AA"));
}

test "Datatransfer -- Implicitly shifted immediate" {
    try std.testing.expectEqual(0x1120_12AA, try ENCODE("ld r1, [r2 + 0x2AA0]"));
    try std.testing.expectEqual(0x1120_2851, try ENCODE("ld r1, [r2 + 0x14400]"));
    try std.testing.expectEqual(0x1120_1992, try ENCODE("ld r1, [r2 + 0x6480]"));
    try std.testing.expectEqual(0x1120_2341, try ENCODE("ld r1, [r2 + 0x34100]"));
}

// --- Move From PSR Instruction

test "MoveFromPsr -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("smv"));
}

test "MoveFromPsr -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("smv!"));
    try std.testing.expectError(error.ParseError, ENCODE("smv r1!"));
}

test "MoveFromPsr -- Encoding" {
    try std.testing.expectEqual(0x0101_8000, ENCODE("smv r1"));
}

// --- Set / Clear PSR Bits Instructions

test "SetClearPsrBits -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("sst"));
    try std.testing.expectError(error.ParseError, ENCODE("scl"));
}

test "SetClearPsrBits -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("sst!"));
    try std.testing.expectError(error.ParseError, ENCODE("sst r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("scl!"));
    try std.testing.expectError(error.ParseError, ENCODE("scl r1!"));
}

test "SetClearPsrBits -- Unencodable immediate value" {
    try std.testing.expectError(error.ParseError, ENCODE("sst 0xFFF"));
}

test "SetClearPsrBits -- Register value" {
    try std.testing.expectEqual(0x2003_8001, ENCODE("sst r1"));
    try std.testing.expectEqual(0x2001_8001, ENCODE("scl r1"));
}

// --- Data Processing Instructions

test "DataProcessing -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("add"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2,"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3 lsl"));
}

test "DataProcessing -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("add!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2,!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3 lsl!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3 lsl r4!"));
    try std.testing.expectError(error.ParseError, ENCODE("add r1, r2, r3 lsl 4!"));
}

test "DataProcessing -- Unencodable immediate value" {
    try std.testing.expectEqual(error.ParseError, ENCODE("add r1, r2, 0x200"));
}

test "DataProcessing -- Unencodable shift value" {
    try std.testing.expectEqual(error.ParseError, ENCODE("add r1, r2, r3 lsl 32"));
    try std.testing.expectEqual(error.ParseError, ENCODE("add r1, r2, r3 lsr 33"));
}

test "DataTransfer -- Opcode variants" {
    try std.testing.expectEqual(0x4120_0003, try ENCODE("add    r1, r2, r3"));
    try std.testing.expectEqual(0x4122_0003, try ENCODE("adc    r1, r2, r3"));
    try std.testing.expectEqual(0x4124_0003, try ENCODE("sub    r1, r2, r3"));
    try std.testing.expectEqual(0x4126_0003, try ENCODE("sbc    r1, r2, r3"));
    try std.testing.expectEqual(0x4128_0003, try ENCODE("and    r1, r2, r3"));
    try std.testing.expectEqual(0x412A_0003, try ENCODE("or     r1, r2, r3"));
    try std.testing.expectEqual(0x412C_0003, try ENCODE("xor    r1, r2, r3"));
    try std.testing.expectEqual(0x412E_0003, try ENCODE("btc    r1, r2, r3"));
    try std.testing.expectEqual(0x4121_0003, try ENCODE("addx   r1, r2, r3"));
    try std.testing.expectEqual(0x4123_0003, try ENCODE("adcx   r1, r2, r3"));
    try std.testing.expectEqual(0x4125_0003, try ENCODE("subx   r1, r2, r3"));
    try std.testing.expectEqual(0x4127_0003, try ENCODE("sbcx   r1, r2, r3"));
    try std.testing.expectEqual(0x4129_0003, try ENCODE("andx   r1, r2, r3"));
    try std.testing.expectEqual(0x412B_0003, try ENCODE("orx    r1, r2, r3"));
    try std.testing.expectEqual(0x412D_0003, try ENCODE("xorx   r1, r2, r3"));
    try std.testing.expectEqual(0x412F_0003, try ENCODE("btcx   r1, r2, r3"));
}

test "DataTransfer -- Immediate value" {
    try std.testing.expectEqual(0x5120_00AA, try ENCODE("add r1, r2, 0xAA"));
}

test "DataTransfer -- Register value, register shift" {
    try std.testing.expectEqual(0x4120_1003, try ENCODE("add r1, r2, r3 lsl r4"));
    try std.testing.expectEqual(0x4120_9003, try ENCODE("add r1, r2, r3 lsr r4"));
    try std.testing.expectEqual(0x4121_9003, try ENCODE("add r1, r2, r3 asr r4"));
}

test "DataTransfer -- Immediate value, register shift" {
    try std.testing.expectEqual(0x5120_10AA, try ENCODE("add r1, r2, 0xAA lsl r4"));
    try std.testing.expectEqual(0x5120_90AA, try ENCODE("add r1, r2, 0xAA lsr r4"));
    try std.testing.expectEqual(0x5121_90AA, try ENCODE("add r1, r2, 0xAA asr r4"));
}

test "DataTransfer -- Register value, immediate shift" {
    try std.testing.expectEqual(0x6120_1003, try ENCODE("add r1, r2, r3 lsl 4"));
    try std.testing.expectEqual(0x6120_9003, try ENCODE("add r1, r2, r3 lsr 4"));
    try std.testing.expectEqual(0x6121_9003, try ENCODE("add r1, r2, r3 asr 4"));
    try std.testing.expectEqual(0x6120_8003, try ENCODE("add r1, r2, r3 lsr 32"));
}

test "DataTransfer -- Immediate value, immediate shift" {
    try std.testing.expectEqual(0x7120_10AA, try ENCODE("add r1, r2, 0xAA lsl 4"));
    try std.testing.expectEqual(0x7120_90AA, try ENCODE("add r1, r2, 0xAA lsr 4"));
    try std.testing.expectEqual(0x7121_90AA, try ENCODE("add r1, r2, 0xAA asr 4"));
    try std.testing.expectEqual(0x7120_80AA, try ENCODE("add r1, r2, 0xAA lsr 32"));
}

// --- Data Processing Pseudo-Instructions

test "DataProcessing Pseudo -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("tst"));
    try std.testing.expectError(error.ParseError, ENCODE("tst r1"));
    try std.testing.expectError(error.ParseError, ENCODE("tst r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("not"));
    try std.testing.expectError(error.ParseError, ENCODE("not r1"));
    try std.testing.expectError(error.ParseError, ENCODE("not r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1,"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1, r2,"));
    try std.testing.expectError(error.ParseError, ENCODE("mov"));
    try std.testing.expectError(error.ParseError, ENCODE("mov,"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1,"));
}

test "DataProcessing Pseudo -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("nop!"));
    try std.testing.expectError(error.ParseError, ENCODE("tst!"));
    try std.testing.expectError(error.ParseError, ENCODE("tst r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("tst r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("not!"));
    try std.testing.expectError(error.ParseError, ENCODE("not r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("not r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1, r2,!"));
    try std.testing.expectError(error.ParseError, ENCODE("lsl, r1, r2, r3!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov,!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov, r1, r2!"));
}

test "DataProcessing Pseudo -- Instruction variants" {
    try std.testing.expectEqual(0x4001_0000, try ENCODE("nop"));
    try std.testing.expectEqual(0x4018_0002, try ENCODE("tst    r1, r2"));
    try std.testing.expectEqual(0x401C_0002, try ENCODE("teq    r1, r2"));
    try std.testing.expectEqual(0x4014_0002, try ENCODE("cmp    r1, r2"));
    try std.testing.expectEqual(0x4010_0002, try ENCODE("cpn    r1, r2"));
    try std.testing.expectEqual(0x512C_03FF, try ENCODE("not    r1, r2"));
    try std.testing.expectEqual(0x512D_03FF, try ENCODE("notx   r1, r2"));
    try std.testing.expectEqual(0x410A_0C02, try ENCODE("lsl    r1, r2, r3"));
    try std.testing.expectEqual(0x410A_8C02, try ENCODE("lsr    r1, r2, r3"));
    try std.testing.expectEqual(0x410B_8C02, try ENCODE("asr    r1, r2, r3"));
    try std.testing.expectEqual(0x410B_0C02, try ENCODE("lslx   r1, r2, r3"));
    try std.testing.expectEqual(0x4121_0000, try ENCODE("mov    r1, r2"));
}

// --- Branch Instructions

test "Branch -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, INST("b"));
}

test "Branch -- Unexpected token" {
    try std.testing.expectError(error.ParseError, INST("b!"));
    try std.testing.expectError(error.ParseError, INST("b r1!"));
    try std.testing.expectError(error.ParseError, INST("b label!"));
}

test "Branch -- Instruction variants, register" {
    try std.testing.expectEqual(Instruction{ .encoding = 0x8000_0001 }, INST("beq     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8100_0001 }, INST("bne     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8200_0001 }, INST("bcs     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8300_0001 }, INST("bcc     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8400_0001 }, INST("bmi     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8500_0001 }, INST("bpl     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8600_0001 }, INST("bvs     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8700_0001 }, INST("bvc     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8800_0001 }, INST("bhi     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8900_0001 }, INST("bls     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8A00_0001 }, INST("bge     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8B00_0001 }, INST("blt     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8C00_0001 }, INST("bgt     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8D00_0001 }, INST("ble     r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0x8E00_0001 }, INST("b       r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA000_0001 }, INST("bleq    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA100_0001 }, INST("blne    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA200_0001 }, INST("blcs    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA300_0001 }, INST("blcc    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA400_0001 }, INST("blmi    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA500_0001 }, INST("blpl    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA600_0001 }, INST("blvs    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA700_0001 }, INST("blvc    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA800_0001 }, INST("blhi    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xA900_0001 }, INST("blls    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAA00_0001 }, INST("blge    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAB00_0001 }, INST("bllt    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAC00_0001 }, INST("blgt    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAD00_0001 }, INST("blle    r1"));
    try std.testing.expectEqual(Instruction{ .encoding = 0xAE00_0001 }, INST("bl      r1"));
}

test "Branch -- Instruction variants, label" {
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8000_0000, .reloc = "label" }, INST("beq     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8100_0000, .reloc = "label" }, INST("bne     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8200_0000, .reloc = "label" }, INST("bcs     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8300_0000, .reloc = "label" }, INST("bcc     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8400_0000, .reloc = "label" }, INST("bmi     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8500_0000, .reloc = "label" }, INST("bpl     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8600_0000, .reloc = "label" }, INST("bvs     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8700_0000, .reloc = "label" }, INST("bvc     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8800_0000, .reloc = "label" }, INST("bhi     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8900_0000, .reloc = "label" }, INST("bls     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8A00_0000, .reloc = "label" }, INST("bge     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8B00_0000, .reloc = "label" }, INST("blt     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8C00_0000, .reloc = "label" }, INST("bgt     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8D00_0000, .reloc = "label" }, INST("ble     label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0x8E00_0000, .reloc = "label" }, INST("b       label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA000_0000, .reloc = "label" }, INST("bleq    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA100_0000, .reloc = "label" }, INST("blne    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA200_0000, .reloc = "label" }, INST("blcs    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA300_0000, .reloc = "label" }, INST("blcc    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA400_0000, .reloc = "label" }, INST("blmi    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA500_0000, .reloc = "label" }, INST("blpl    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA600_0000, .reloc = "label" }, INST("blvs    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA700_0000, .reloc = "label" }, INST("blvc    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA800_0000, .reloc = "label" }, INST("blhi    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xA900_0000, .reloc = "label" }, INST("blls    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAA00_0000, .reloc = "label" }, INST("blge    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAB00_0000, .reloc = "label" }, INST("bllt    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAC00_0000, .reloc = "label" }, INST("blgt    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAD00_0000, .reloc = "label" }, INST("blle    label"));
    try std.testing.expectEqualDeep(Instruction{ .encoding = 0xAE00_0000, .reloc = "label" }, INST("bl      label"));
}

// --- Move Immediate Instruction

test "MoveImmediate -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("mvi"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1,"));
}

test "MoveImmediate -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("mvi!"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1,!"));
}

test "MoveImmediate -- Unencodable value" {
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1, 0x01FF_FFFF"));
    try std.testing.expectError(error.ParseError, ENCODE("mvi r1, -0x01FF_FFFF"));
}

test "MoveImmediate -- Encoding" {
    try std.testing.expectEqual(0xC100_00AA, ENCODE("mvi r1, 0xAA"));
    try std.testing.expectEqual(0xD1FF_FF56, ENCODE("mvi r1, -0xAA"));
}

// --- Software Interrupt Instruction

test "SoftwareInterrupt -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("swi!"));
    try std.testing.expectError(error.ParseError, ENCODE("swi 0xAA!"));
}

test "SoftwareInterrupt -- Unencodable value" {
    try std.testing.expectError(error.ParseError, ENCODE("swi 0xDEAD_BEEF"));
}

test "SoftwareInterrupt -- Encoding" {
    try std.testing.expectEqual(0xFEAD_BEEF, ENCODE("swi 0x0EAD_BEEF"));
}

// --- Move32 Instruction

test "Move32 -- Unexpected EOL" {
    try std.testing.expectError(error.ParseError, ENCODE("mov32"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1,"));
}

test "Move32 -- Unexpected token" {
    try std.testing.expectError(error.ParseError, ENCODE("mov32!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1,!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1, label!"));
    try std.testing.expectError(error.ParseError, ENCODE("mov32 r1, 0xDEAD_BEEF!"));
}

test "Move32 -- Unencodable value" {
    try std.testing.expectError(error.ParseError, ENCODE("mov32, r1, 0xFFFF_FFFF_FFFF"));
}

test "Move32 -- Encoding, label" {
    try std.testing.expectEqualDeep(
        Instruction{ .encoding = 0xC100_0000, .extension = 0x7101_6000, .reloc = "label" },
        INST("mov32 r1, label"),
    );
}

test "Move32 -- Encoding, immediate" {
    try std.testing.expectEqual(
        Instruction{ .encoding = 0xC1AD_BEEF, .extension = 0x7101_60DE },
        INST("mov32 r1, 0xDEADBEEF"),
    );
}
